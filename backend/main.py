# backend/main.py (CLEANED) - generated by ChatGPT

import random
import os
import uuid
import json
import shutil
import secrets
import asyncio
import base64
import io
import time
from datetime import datetime, timedelta
from contextlib import asynccontextmanager
from typing import List, Optional, Dict
from urllib.parse import urlencode
from fastapi import status as http_status
import enum
from dotenv import load_dotenv
import uvicorn
from fastapi import (
    Depends,
    FastAPI,
    HTTPException,
    BackgroundTasks,
    Request,
    WebSocket,
    
    File,
    UploadFile,
    Response,
)
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import OAuth2PasswordRequestForm, OAuth2PasswordBearer
from fastapi.staticfiles import StaticFiles
from fastapi.responses import JSONResponse, PlainTextResponse, RedirectResponse
from passlib.context import CryptContext
from jose import JWTError, jwt
from pydantic import BaseModel, EmailStr, ConfigDict


from sqlalchemy import (
    create_engine,
    Column,
    Integer,
    String,
    Float,
    DateTime,
    ForeignKey,
    Text,
    Boolean,
    func, 
    UniqueConstraint 
)
from datetime import datetime, UTC
from sqlalchemy.orm import declarative_base,sessionmaker, Session, relationship, selectinload
#from sqlalchemy.ext.declarative import declarative_base

from starlette.middleware.sessions import SessionMiddleware
from starlette.websockets import WebSocketDisconnect

from authlib.integrations.starlette_client import OAuth
from fastapi_mail import ConnectionConfig, FastMail, MessageSchema
from geoip2.database import Reader
import httpx
import stripe
import requests
import configparser

# ML / plotting
import numpy as np
import pandas as pd
from sklearn.preprocessing import MinMaxScaler, LabelEncoder
from sklearn.metrics import classification_report, confusion_matrix
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt
import seaborn as sns
import io
import base64
from model_definition import create_model
# Optional libs
try:
    import flwr as fl
except Exception:
    fl = None

# Local model factory
from model_definition import create_model
import subprocess
import sys
from typing import List, Optional, Dict, Tuple # <<< Assurez-vous que Tuple est importé
from sqlalchemy.orm import joinedload
import google.generativeai as genai
import geoip2.database
# ------------------------------------------------------------
# SECTION 2: Global configuration
# ------------------------------------------------------------
print("--- MAIN.PY LOADED - VERSION DU 7 SEPTEMBRE ---")
load_dotenv()
# DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///./fedids_main.db")
SECRET_KEY = os.getenv("SECRET_KEY", "super-secret-dev-key")
ALGORITHM = "HS256"
GEOIP_DB_PATH = os.getenv("GEOIP_DB_PATH", "geoip_db/GeoLite2-City.mmdb")
try:
    print(f"Attempting to load GeoIP database from: {GEOIP_DB_PATH}")
    geoip_reader = geoip2.database.Reader(GEOIP_DB_PATH)
    print("✅ GeoIP database loaded successfully.")
except FileNotFoundError:
    geoip_reader = None
    print(f"❌ FATAL ERROR: GeoIP database not found at '{GEOIP_DB_PATH}'. Geolocation will be disabled.")
    print("   -> Make sure you have downloaded the file and placed it in the correct directory.")
except Exception as e:
    geoip_reader = None
    print(f"❌ FATAL ERROR: Failed to load GeoIP database. Error: {e}")
PREMIUM_PLAN_PRICE = int(os.getenv("PREMIUM_PLAN_PRICE", "200"))
FRONTEND_BASE = os.getenv("FRONTEND_BASE", "http://localhost:5173")
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")

if not GEMINI_API_KEY:
    print("❌ ERREUR: La variable d'environnement GEMINI_API_KEY n'est pas définie dans votre fichier .env")
else:
    try:
        genai.configure(api_key=GEMINI_API_KEY)
        print("✅ Clé API configurée. Demande de la liste des modèles...")
        
        # Demander à Google la liste des modèles disponibles
        for m in genai.list_models():
            # On cherche les modèles qui supportent la méthode 'generateContent'
            if 'generateContent' in m.supported_generation_methods:
                print(f"  - Modèle trouvé : {m.name}")

    except Exception as e:
        print(f"❌ Une erreur est survenue lors de la communication avec l'API de Google: {e}")



mail_conf = ConnectionConfig(
    MAIL_USERNAME=os.getenv("MAIL_USERNAME"),
    MAIL_PASSWORD=os.getenv("MAIL_PASSWORD"),
    MAIL_FROM=os.getenv("MAIL_FROM"),
    MAIL_PORT=int(os.getenv("MAIL_PORT", 587)),
    MAIL_SERVER=os.getenv("MAIL_SERVER"),
    MAIL_STARTTLS=True,
    MAIL_SSL_TLS=False,
)
stripe.api_key = os.getenv("STRIPE_SECRET_KEY")

try:
    geoip_reader = Reader(GEOIP_DB_PATH)
except Exception:
    geoip_reader = None





# ------------------------------------------------------------
# SECTION 3: Database setup
# ------------------------------------------------------------
DATABASE_URL = os.getenv("DATABASE_URL")
Base = declarative_base()
#engine = create_engine(DATABASE_URL, connect_args={"check_same_thread": False})
engine = create_engine(DATABASE_URL)

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# ------------------------------------------------------------
# SECTION 4: SQLAlchemy models
# ------------------------------------------------------------

class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True)
    email = Column(String, unique=True, nullable=False)
    username = Column(String, unique=True)
    hashed_password = Column(String, nullable=True)
    
    # --- NOUVEAUX CHAMPS ---
    full_name = Column(String, nullable=True)
    company = Column(String, nullable=True)
    job_title = Column(String, nullable=True) # Ex: "Ingénieur Sécurité", "Manager"
    country = Column(String, nullable=True)
    
    role = Column(String, default="user") # user, premium, admin
    is_active = Column(Boolean, default=False)
    verification_code = Column(String, nullable=True)
    password_reset_token = Column(String, nullable=True) # Pour le mot de passe oublié
    password_reset_expires = Column(DateTime, nullable=True)
    
    google_id = Column(String, unique=True, nullable=True)
    profile_picture_url = Column(String, nullable=True)
    subscription_valid_until = Column(DateTime, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    
    devices = relationship("Device", back_populates="owner", cascade="all, delete-orphan")
    tickets = relationship("Ticket", foreign_keys="[Ticket.user_id]", back_populates="user")


class Device(Base):
    __tablename__ = "devices"
  
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, nullable=False)
    api_key = Column(String, unique=True, default=lambda: uuid.uuid4().hex)
    owner_id = Column(Integer, ForeignKey("users.id"))
    
    # === LES MODIFICATIONS SONT ICI ===
    description = Column(Text, nullable=True)
    ip_address = Column(String, nullable=True)
    mac_address = Column(String, nullable=True)
    
    # On lie l'appareil à une catégorie
    category_id = Column(Integer, ForeignKey("device_categories.id"), nullable=True)
    category = relationship("DeviceCategory")
    # === FIN DES MODIFICATIONS ===
    
    owner = relationship("User", back_populates="devices")
    prevention_enabled = Column(Boolean, default=False)
    registration_token = Column(String, unique=True, nullable=True)
    status_records = relationship(
        "DeviceStatus",
        back_populates="device",
        cascade="all, delete-orphan"
    )

class DeviceStatus(Base):
    __tablename__ = "device_status"
    id = Column(Integer, primary_key=True)
    device_api_key = Column(String, ForeignKey("devices.api_key"), unique=True)
    last_seen = Column(DateTime, default=datetime.utcnow)
    status = Column(String, default="offline")
    device = relationship("Device", back_populates="status_records")




class AttackLog(Base):
    __tablename__ = "attack_logs"
    id = Column(Integer, primary_key=True)
    timestamp = Column(DateTime, default=datetime.utcnow)
    source_ip = Column(String)
    attack_type = Column(String)
    confidence = Column(Float)
    
    # === LA MODIFICATION EST ICI ===
    # On lie l'attaque à un appareil via sa clé API.
    # On ne met pas de ForeignKey pour plus de flexibilité (un appareil peut être supprimé
    # mais on veut garder son historique d'attaques).
    device_api_key = Column(String, index=True, nullable=True)
    
    latitude = Column(Float, nullable=True)
    longitude = Column(Float, nullable=True)
    city = Column(String, nullable=True)
    country = Column(String, nullable=True)


class Client(Base):
    __tablename__ = "clients"
    id = Column(Integer, primary_key=True)
    flower_id = Column(String, unique=True)
    name = Column(String)
    status = Column(String, default="active")
    notes = Column(Text, nullable=True)
    registered_at = Column(DateTime, default=datetime.utcnow)
    history_records = relationship("ClientHistory", back_populates="client", cascade="all, delete-orphan")
    owner_id = Column(Integer, ForeignKey("users.id"), nullable=True)
    owner = relationship("User")

class ClientHistory(Base):
    __tablename__="client_history";id=Column(Integer,primary_key=True);client_id=Column(Integer,ForeignKey("clients.id"));server_round=Column(Integer);accuracy=Column(Float);loss=Column(Float);timestamp=Column(DateTime,default=datetime.utcnow);client=relationship("Client",back_populates="history_records")

class Payment(Base):
    __tablename__="payments";id=Column(Integer,primary_key=True);user_id=Column(Integer,ForeignKey("users.id"));stripe_payment_intent_id=Column(String,unique=True);amount=Column(Integer);currency=Column(String);status=Column(String);created_at=Column(DateTime,default=datetime.utcnow);user=relationship("User")

class AnalysisHistory(Base):
    __tablename__ = "analysis_history"
    id = Column(Integer, primary_key=True)
    filename = Column(String)
    timestamp = Column(DateTime, default=datetime.utcnow)
    # On stocke les rapports sous forme de texte JSON
    classification_report = Column(Text) 
    confusion_matrix_b64 = Column(Text) # Assez long pour une chaîne base64
    
    # On lie l'analyse à l'admin qui l'a lancée
    admin_id = Column(Integer, ForeignKey("users.id"))

    
class Ticket(Base):
    __tablename__ = "tickets"
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    subject = Column(String, nullable=False)
    assigned_admin_id = Column(Integer, ForeignKey("users.id"), nullable=True)
    
    # --- NOUVEAUX CHAMPS ---
    category = Column(String, default="general")
    status = Column(String, default="open")
    priority = Column(String, default="medium")
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # === LA CORRECTION EST ICI ===
    
    # Relation pour le créateur du ticket
    user = relationship("User", foreign_keys=[user_id], back_populates="tickets")
    
    # Relation pour l'admin assigné
    assigned_admin = relationship("User", foreign_keys=[assigned_admin_id])
    
    messages = relationship("TicketMessage", back_populates="ticket", cascade="all, delete-orphan")


class FaqArticle(Base):
    __tablename__ = "faq_articles"
    id = Column(Integer, primary_key=True)
    question = Column(String, nullable=False)
    answer = Column(Text, nullable=False)
    keywords = Column(String) # Mots-clés séparés par des virgules
    category = Column(String, default="general") # general, technical, billing

class TicketMessage(Base):
    __tablename__ = "ticket_messages"
    id = Column(Integer, primary_key=True)
    ticket_id = Column(Integer, ForeignKey("tickets.id"))
    author_id = Column(Integer, ForeignKey("users.id")) # L'ID de l'utilisateur ou de l'admin
    message = Column(Text, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    
    ticket = relationship("Ticket", back_populates="messages")
    author = relationship("User", foreign_keys=[author_id])

class ChatLog(Base):
    __tablename__ = "chat_logs"
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    question = Column(Text, nullable=False)
    # On pourrait aussi stocker la réponse du modèle si on le voulait
    # answer = Column(Text) 
    timestamp = Column(DateTime, default=datetime.utcnow)
    
    user = relationship("User")
def get_db():db=SessionLocal();yield db;db.close()


class DeviceCategory(Base):
    __tablename__ = "device_categories"
    id = Column(Integer, primary_key=True)
    name = Column(String, nullable=False)
    owner_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    
    # Relation pour que l'on puisse facilement accéder à l'utilisateur
    owner = relationship("User")



class PreventionLog(Base):
    __tablename__ = "prevention_logs"
    id = Column(Integer, primary_key=True)
    
    # === LA CORRECTION EST ICI ===
    # Le nom de la colonne doit correspondre à la clé dans le JSON
    # que vous envoyez depuis le client.
    api_key = Column(String, ForeignKey("devices.api_key"), index=True)
    
    action_taken = Column(String, nullable=False)
    source_ip_blocked = Column(String)
    attack_type_prevented = Column(String)
    timestamp = Column(DateTime, default=datetime.utcnow)


# ------------------------------------------------------------
# SECTION 5: Pydantic models (schemas)
# ------------------------------------------------------------
# --- Pydantic Models ---
class UserCreate(BaseModel):
    email:EmailStr
    username:str
    password:str
    full_name: str
    company: Optional[str] = None
    country: Optional[str] = None
class PasswordResetRequest(BaseModel):
    email: EmailStr

class PasswordResetConfirm(BaseModel):
    token: str
    new_password: str

class UserProfileUpdate(BaseModel):
    username: Optional[str] = None
    full_name: Optional[str] = None
    company: Optional[str] = None
    
    # === AJOUTEZ CES DEUX LIGNES ===
    country: Optional[str] = None
    job_title: Optional[str] = None
    
    
class UserPublic(BaseModel):
    id: int
    email: str
    username: Optional[str] = None
    role: str
    profile_picture_url: Optional[str] = None
    subscription_valid_until: Optional[datetime] = None
    full_name: Optional[str] = None
    company: Optional[str] = None
    
    # === AJOUTEZ CES DEUX LIGNES ===
    country: Optional[str] = None
    job_title: Optional[str] = None
    
    # --- ASSUREZ-VOUS QUE CES CHAMPS SONT AUSSI LÀ ---
    is_active: bool
    created_at: datetime

    class Config:
        from_attributes = True
class UserAdminView(UserPublic):device_count:int;devices_with_prevention_on:int;payment_count:int
class Token(BaseModel):access_token:str;token_type:str;user:UserPublic

class DeviceCreate(BaseModel):
    name: str
    description: Optional[str] = None
    ip_address: Optional[str] = None
    mac_address: Optional[str] = None
    category_id: Optional[int] = None

class DeviceCategoryCreate(BaseModel):
    name: str

class DeviceCategoryPublic(DeviceCategoryCreate):
    id: int
    class Config: from_attributes = True

class DevicePublic(BaseModel):
    id: int
    name: str
    api_key: str
    registration_token: Optional[str] = None

    prevention_enabled: bool
    description: Optional[str] = None
    ip_address: Optional[str] = None
    mac_address: Optional[str] = None
    category: Optional[DeviceCategoryPublic] = None # On inclut l'objet catégorie complet
    class Config: from_attributes = True

class DeviceStatusPublic(BaseModel):
    last_seen: Optional[datetime]
    status: str

    class Config:
        from_attributes = True

class DeviceAdminView(DevicePublic):
    owner_email: str
    status: Optional[str] = 'unknown'

class DeviceWithStatus(DevicePublic):
    status_info: Optional[DeviceStatusPublic] = None



class HeartbeatPayload(BaseModel):
    api_key: str


class DashboardStats(BaseModel):
    device_count: int
    attacks_this_week: int
    last_attack_timestamp: Optional[datetime] = None


class FLClientRegistration(BaseModel):
    api_key: str
    flower_cid: str

class AnalysisHistoryPublic(BaseModel):
    id: int
    filename: str
    timestamp: datetime
    class Config: from_attributes = True

class VerificationData(BaseModel):email:EmailStr;code:str
class AttackReport(BaseModel):
    source_ip:str
    attack_type:str
    confidence:float
    api_key: str
class AttackLogPublic(BaseModel):id:int;timestamp:datetime;source_ip:str;attack_type:str;confidence:float;city:Optional[str]=None;country:Optional[str]=None;model_config=ConfigDict(from_attributes=True)
class ClientModel(BaseModel):
    id:int
    flower_id:str
    name:str
    status:str
    notes:Optional[str]
    registered_at:datetime
    owner_username: Optional[str] = None
    owner_email: Optional[str] = None
    model_config=ConfigDict(from_attributes=True)
   
class AdminStats(BaseModel):total_users:int;premium_users:int;total_devices:int;online_devices:int;total_attacks_24h:int

class FLRoundHistory(BaseModel):
    server_round: int
    accuracy: float
    loss: float
    timestamp: datetime
    class Config: from_attributes = True

class EvaluationResult(BaseModel):
    report: dict
    confusion_matrix_b64: str

class HistoryModel(BaseModel):
    server_round: int
    accuracy: float
    loss: float
    timestamp: datetime

    class Config:
        from_attributes = True

class FLStatus(BaseModel): server_round: int; accuracy: float ;  loss: float
class ClientHistoryPayload(BaseModel):
    client_flower_id: str; server_round: int; accuracy: float; loss: float

class ClientHistoryAdminView(BaseModel):
    server_round: int
    accuracy: float
    loss: float
    timestamp: datetime
    class Config: from_attributes = True

class ClientAdminView(BaseModel):
    id: int
    flower_id: str
    name: str
    status: str
    registered_at: datetime
    # On ajoute des informations sur le propriétaire
    owner_username: Optional[str] = None
    owner_email: Optional[str] = None
    class Config: from_attributes = True

class GlobalRoundHistory(BaseModel):
    server_round: int
    accuracy: Optional[float] = None
    loss: Optional[float] = None
    timestamp: datetime

    class Config:
        from_attributes = True


class TrainingStatus(BaseModel):
    is_running: bool
    pid: Optional[int] = None # Process ID
class TicketCreate(BaseModel):
   category: str
   subject: str
   message: str

class TicketMessageCreate(BaseModel):
    message: str

class TicketResponsePublic(BaseModel):
    id: int
    author_id: int
    message: str
    created_at: datetime
    class Config: from_attributes = True

class TicketPublic(BaseModel):
    id: int
    user_id: int
    subject: str
    status: str
    priority: str
    created_at: datetime
    updated_at: datetime
    responses: List[TicketResponsePublic] = []
    class Config: from_attributes = True


class ForgotPasswordRequest(BaseModel):
    email: EmailStr

class ResetPasswordRequest(BaseModel):
    token: str
    new_password: str


class ChatQuery(BaseModel):
    question: str
    history: List[Dict[str, str]] # ex: [{"role": "user", "text": "..."}, {"role": "model", "text": "..."}]

class ChatResponse(BaseModel):
    answer: str


class ChatStat(BaseModel):
    question: str
    count: int
class TicketCategoryStat(BaseModel):
    category: str
    count: int


class AttackTypeStat(BaseModel):
    attack_type: str
    count: int

class PreventionLogCreate(BaseModel):
    api_key: str
    action_taken: str
    source_ip_blocked: str
    attack_type_prevented: str
class PreventionLogPublic(BaseModel):
    action_taken: str
    timestamp: datetime
    class Config: from_attributes = True


class DeviceUpdate(BaseModel):
    name: str
    description: Optional[str] = None
    ip_address: Optional[str] = None
    mac_address: Optional[str] = None
    category_id: Optional[int] = None
# ------------------------------------------------------------
# SECTION 6: Helpers (auth, utils)
# ------------------------------------------------------------
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/auth/login")
oauth = OAuth()


def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)


def verify_password(password: str, hashed: str) -> bool:
    return pwd_context.verify(password, hashed)


def create_access_token(data: dict):
    expire = datetime.utcnow() + timedelta(days=1)
    payload = {**data, "exp": expire}
    return jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)


def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


async def get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)):
    exc = HTTPException(status_code=401, detail="Invalid token")
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username = payload.get("sub")
        if not username:
            raise exc
    except JWTError:
        raise exc
    user = db.query(User).filter(User.username == username).first()
    if not user:
        raise exc
    return user


async def get_current_admin_user(user: User = Depends(get_current_user)):
    if user.role != "admin":
        raise HTTPException(status_code=403, detail="Not authorized")
    return user


def enrich_geoip(ip: str):
    if not geoip_reader:
        return None, None, None, None
    
    if not ip or ip.startswith(("192.168", "10.", "127.")):
        return None, None, None, None
        
    try:
        response = geoip_reader.city(ip)
        country = response.country.name
        
        # === LA CORRECTION EST ICI ===
        # On essaie de prendre les coordonnées de la ville en premier
        if response.location.latitude and response.location.longitude:
            lat = response.location.latitude
            lon = response.location.longitude
            city = response.city.name
        # Si la ville n'a pas de coordonnées, on prend celles du pays
        elif response.country.location.latitude and response.country.location.longitude:
            lat = response.country.location.latitude
            lon = response.country.location.longitude
            city = None # On indique explicitement qu'on n'a pas de ville
        else:
            # Si on n'a aucune coordonnée, on abandonne
            return None, None, country, None
            
        return lat, lon, city, country
        
    except geoip2.errors.AddressNotFoundError:
        return None, None, None, None
    except Exception:
        return None, None, None, None


async def send_ntfy_notification(attack: AttackLog):
    try:
        message = f"🚨 {attack.attack_type} from {attack.source_ip} ({attack.country or 'Unknown'})"
        async with httpx.AsyncClient() as client:
            await client.post(
                os.getenv("NTFY_TOPIC_URL", "https://ntfy.sh/ok"),
                data=message.encode("utf-8"),
                headers={"Title": "FedIDS Alert", "Priority": "high"},
            )
    except Exception as e:
        print("❌ Ntfy error:", e)


def log_to_json_serializable(log_entry: AttackLog) -> Dict:
    return {
        "id": log_entry.id,
        "timestamp": log_entry.timestamp.isoformat(),
        "source_ip": log_entry.source_ip,
        "attack_type": log_entry.attack_type,
        "confidence": log_entry.confidence,
        "latitude": log_entry.latitude,
        "longitude": log_entry.longitude,
        "city": log_entry.city,
        "country": log_entry.country,
    }


# ------------------------------------------------------------
# SECTION 7: Lifespan & app instance
# ------------------------------------------------------------
@asynccontextmanager
async def lifespan(app: FastAPI):
    oauth.register(
        name="google",
        client_id=os.getenv("GOOGLE_CLIENT_ID"),
        client_secret=os.getenv("GOOGLE_CLIENT_SECRET"),
        server_metadata_url="https://accounts.google.com/.well-known/openid-configuration",
        client_kwargs={"scope": "openid email profile"},
    )
    Base.metadata.create_all(bind=engine)
    # create default admin if none
    with SessionLocal() as db:
        # On vérifie si un utilisateur avec cet email ou ce username existe déjà
        user_exists = db.query(User).filter(
            (User.email == "yasmine@fedids.io") | (User.username == "yasmine")
        ).first()
        
        # On ne crée l'admin que s'il n'existe PAS
        if not user_exists:
            print("Admin user 'yasmine' not found, creating new one...")
            admin = User(
                email="yasmine@fedids.io",
                username="yasmine",
                hashed_password=get_password_hash("yasmine"),
                role="admin",
                is_active=True,
            )
            db.add(admin)
            db.commit()
            print("✅ Admin user 'yasmine' created successfully.")
        else:
            print("Admin user 'yasmine' already exists. Skipping creation.")
    # === FIN DE LA CORRECTION ===
            
    yield

app = FastAPI(title="FedIds API", lifespan=lifespan)

# ------------------------------------------------------------
# SECTION 8: Middlewares & static files
# ------------------------------------------------------------
os.makedirs("static/profile_pics", exist_ok=True)
app.mount("/static", StaticFiles(directory="static"), name="static")
app.add_middleware(SessionMiddleware, secret_key=SECRET_KEY)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


# WebSocket manager
class ConnectionManager:
    def __init__(self):
        self.channels: Dict[str, List[WebSocket]] = {"attacks": [], "fl_status": []}

    async def connect(self, ws: WebSocket, channel: str):
        await ws.accept()
        self.channels.setdefault(channel, []).append(ws)

    def disconnect(self, ws: WebSocket, channel: str):
        if ws in self.channels.get(channel, []):
            self.channels[channel].remove(ws)

    async def broadcast(self, msg: str, ch: str):
        await asyncio.gather(*(c.send_text(msg) for c in self.channels.get(ch, [])), return_exceptions=True)


manager = ConnectionManager()


# ------------------------------------------------------------
# SECTION 9: Routes
# (kept your logic; fixed small errors and duplicates)
# ------------------------------------------------------------



@app.post("/api/auth/verify")
def verify_email(data: VerificationData, db: Session = Depends(get_db)):
    user = db.query(User).filter_by(email=data.email).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    if user.is_active:
        return {"message": "Already activated"}
    if user.verification_code != data.code:
        raise HTTPException(status_code=400, detail="Invalid code")
    user.is_active = True
    user.verification_code = None
    db.commit()
    return {"message": "Account activated"}


@app.post("/api/auth/login", response_model=Token)
def login(db: Session = Depends(get_db), f: OAuth2PasswordRequestForm = Depends()):
    user = db.query(User).filter(User.username == f.username).first()
    if not user or not user.hashed_password or not verify_password(f.password, user.hashed_password):
        raise HTTPException(status_code=401, detail="Invalid credentials")
    token = create_access_token({"sub": user.username})
    return Token(access_token=token, token_type="bearer", user=UserPublic.model_validate(user))

@app.post("/api/auth/request-password-reset")
async def request_password_reset(request: PasswordResetRequest, background_tasks: BackgroundTasks, db: Session = Depends(get_db)):
    user = db.query(User).filter(User.email == request.email).first()
    if not user:
        # On ne révèle pas si l'email existe ou non pour des raisons de sécurité
        return {"message": "If an account with this email exists, a password reset link has been sent."}

    # Générer un token sécurisé et une date d'expiration (ex: 1 heure)
    token = secrets.token_urlsafe(32)
    expires = datetime.utcnow() + timedelta(hours=1)
    
    user.password_reset_token = token
    user.password_reset_expires = expires
    db.commit()

    # Envoyer l'email avec le lien de réinitialisation
    reset_link = f"http://localhost:5173/reset-password?token={token}"
    fm = FastMail(mail_conf)
    msg = MessageSchema(
        subject="FedIds - Password Reset Request",
        recipients=[user.email],
        body=f"<p>Please click the following link to reset your password: <a href='{reset_link}'>{reset_link}</a></p>",
        subtype="html"
    )
    background_tasks.add_task(fm.send_message, msg)
    
    return {"message": "Password reset link sent."}

@app.post("/api/auth/confirm-password-reset")
def confirm_password_reset(request: PasswordResetConfirm, db: Session = Depends(get_db)):
    user = db.query(User).filter(
        User.password_reset_token == request.token,
        User.password_reset_expires > datetime.utcnow()
    ).first()

    if not user:
        raise HTTPException(status_code=400, detail="Invalid or expired password reset token.")

    # Mettre à jour le mot de passe et invalider le token
    user.hashed_password = get_password_hash(request.new_password)
    user.password_reset_token = None
    user.password_reset_expires = None
    db.commit()

    return {"message": "Password has been reset successfully."}
@app.get("/api/users/me", response_model=UserPublic)
async def read_users_me(current_user: User = Depends(get_current_user)):
    return current_user


@app.put("/api/users/me/profile", response_model=UserPublic)
def update_user_profile(
    profile_data: UserProfileUpdate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    update_data = profile_data.model_dump(exclude_unset=True)
    for key, value in update_data.items():
        setattr(current_user, key, value)
    db.commit()
    db.refresh(current_user)
    return current_user


@app.post("/api/users/me/upload-picture", response_model=UserPublic)
async def upload_profile_picture(
    file: UploadFile = File(...), user: User = Depends(get_current_user), db: Session = Depends(get_db)
):
    file_ext = os.path.splitext(file.filename)[1]
    filename = f"{user.id}_{uuid.uuid4().hex}{file_ext}"
    file_path = os.path.join("static", "profile_pics", filename)
    with open(file_path, "wb") as buffer:
        shutil.copyfileobj(file.file, buffer)
    user.profile_picture_url = f"/static/profile_pics/{filename}"
    db.commit()
    db.refresh(user)
    return user


@app.get("/profile-pic/{filename}")
async def get_profile_pic(filename: str):
    file_path = os.path.join("static", "profile_pics", filename)
    if not os.path.exists(file_path):
        raise HTTPException(status_code=404, detail="Profile picture not found")
    return {"url": f"/static/profile_pics/{filename}"}


@app.post("/api/users/me/upgrade-to-premium", response_model=UserPublic)
def upgrade_user_to_premium(current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    user = current_user
    
    if user.role != "premium":
        user.role = "premium"
    
    user.subscription_valid_until = datetime.utcnow() + timedelta(days=90)
    
    # === LA CORRECTION EST ICI ===
    # On simule la création d'un enregistrement de paiement
    new_payment = Payment(
        user_id=user.id,
        stripe_payment_intent_id=f"sim_{uuid.uuid4().hex}", # ID simulé
        amount=200, # Montant en centimes
        currency="eur",
        status="succeeded"
    )
    db.add(new_payment)
    # === FIN DE LA CORRECTION ===
    
    db.commit()
    db.refresh(user)
    
    return UserPublic.model_validate(user)

@app.post("/api/devices/complete-installation/{reg_token}", status_code=200)
def complete_installation(reg_token: str, db: Session = Depends(get_db)):
    """
    Invalide un token d'enregistrement une fois que l'installation est terminée.
    """
    device = db.query(Device).filter(Device.registration_token == reg_token).first()
    if device:
        device.registration_token = None
        db.commit()
    return {"message": "Installation completed and token invalidated."}
@app.post("/api/devices/register", response_model=DevicePublic)
def register_device(device_in: DeviceCreate, user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    existing_device = db.query(Device).filter(Device.name == device_in.name, Device.owner_id == user.id).first()
    if existing_device:
        raise HTTPException(status_code=400, detail=f"A device with the name '{device_in.name}' already exists.")

    new_device = Device(
        **device_in.model_dump(), 
        owner_id=user.id,
        registration_token=secrets.token_hex(16)
    )
    db.add(new_device)
    db.commit()
    db.refresh(new_device)

    return new_device

    
    # On renvoie l'objet. Pydantic s'occupera de le convertir.
    return new_device

# Remplacez votre fonction get_install_script par celle-ci :
# Dans backend/main.py

@app.get("/api/devices/install/{reg_token}", response_class=PlainTextResponse)
def get_install_script(reg_token: str, db: Session = Depends(get_db)):
    """
    Trouve un appareil par son token, l'invalide, et renvoie le script d'installation.
    """
    device = db.query(Device).filter(Device.registration_token == reg_token).first()
    if not device:
        return "echo '❌ Error: Invalid or expired registration token.'; exit 1"

    # === LA CORRECTION EST ICI ===
    # On récupère la VRAIE clé API
    api_key = device.api_key
    
    # On invalide le token d'enregistrement dès qu'il est utilisé.
    device.registration_token = None
    db.commit()

    github_client_repo_url = "https://github.com/yasminegh01/fedids-iiot-client.git"

    script_content = f"""#!/bin/bash
set -e
echo "--- FedIds IIoT Online Installer ---"
echo "➡️ Step 1/4: Installing system dependencies..."
sudo apt-get update && sudo apt-get install -y git python3.11 python3.11-venv libasound2-dev
echo "➡️ Step 2/4: Downloading client source code..."
git clone {github_client_repo_url} iiot_client
cd iiot_client
echo "➡️ Step 3/4: Creating venv and installing packages..."
python3.11 -m venv venv
source venv/bin/activate
pip install -r requirements.txt
echo "➡️ Step 4/4: Configuring device..."
echo "[device]" > config.ini
# On écrit la VRAIE clé API dans le fichier de configuration
echo "api_key = {api_key}" >> config.ini
echo ""
echo "🚀 Installation Complete!"
"""
    return script_content
@app.get("/api/devices/my-devices-with-status", response_model=List[DeviceWithStatus])
def get_my_devices_with_status(user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    five_min = datetime.utcnow() - timedelta(minutes=5)
    db.query(DeviceStatus).filter(DeviceStatus.last_seen < five_min).update({"status": "offline"}, synchronize_session=False)
    db.commit()
    response = []
    for d in user.devices:
        status_obj = db.query(DeviceStatus).filter_by(device_api_key=d.api_key).first()
        response.append(
            DeviceWithStatus(**DevicePublic.model_validate(d).model_dump(), status_info=DeviceStatusPublic.model_validate(status_obj) if status_obj else None)
        )
    return response


@app.post("/api/devices/heartbeat")
def device_heartbeat(payload: HeartbeatPayload, db: Session = Depends(get_db)):
    d = db.query(Device).filter_by(api_key=payload.api_key).first()
    if not d:
        raise HTTPException(status_code=404, detail="Device not found")
    status_obj = db.query(DeviceStatus).filter_by(device_api_key=d.api_key).first()
    if status_obj:
        status_obj.last_seen = datetime.utcnow()
        status_obj.status = "online"
    else:
        db.add(DeviceStatus(device_api_key=d.api_key, status="online", last_seen=datetime.utcnow()))
    db.commit()
    return {"status": "ok"}


@app.get("/api/devices/{api_key}/settings")
def get_device_settings(api_key: str, db: Session = Depends(get_db)):
    device = db.query(Device).filter(Device.api_key == api_key).first()
    if not device:
        raise HTTPException(status_code=404, detail="Device not found")
    return {"prevention_enabled": device.prevention_enabled}


@app.post("/api/devices/{device_id}/toggle-prevention", response_model=DevicePublic)
def toggle_prevention(device_id: int, user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    if user.role != "premium":
        raise HTTPException(status_code=403, detail="This is a premium feature.")
    device = db.query(Device).filter(Device.id == device_id, Device.owner_id == user.id).first()
    if not device:
        raise HTTPException(status_code=404, detail="Device not found or not owned by user.")
    device.prevention_enabled = not device.prevention_enabled
    db.commit()
    db.refresh(device)
    return device


@app.delete("/api/devices/{device_id}", status_code=http_status.HTTP_204_NO_CONTENT)
def delete_device(
    device_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    device_to_delete = db.query(Device).filter(
        Device.id == device_id,
        Device.owner_id == current_user.id,
    ).first()

    if not device_to_delete:
        raise HTTPException(status_code=404, detail="Device not found.")

    db.delete(device_to_delete)
    db.commit()
    return Response(status_code=http_status.HTTP_204_NO_CONTENT)



@app.get("/api/device-categories", response_model=List[DeviceCategoryPublic])
def get_user_categories(current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    return db.query(DeviceCategory).filter(DeviceCategory.owner_id == current_user.id).all()

@app.post("/api/device-categories", response_model=DeviceCategoryPublic, status_code=201)
def create_category(category_data: DeviceCategoryCreate, current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    new_category = DeviceCategory(**category_data.model_dump(), owner_id=current_user.id)
    db.add(new_category)
    db.commit()
    db.refresh(new_category)
    return new_category

@app.put("/api/devices/{device_id}", response_model=DevicePublic, dependencies=[Depends(get_current_user)])
def update_device(
    device_id: int,
    device_data: DeviceUpdate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Met à jour les informations d'un appareil appartenant à l'utilisateur.
    """
    # 1. On cherche l'appareil en s'assurant qu'il appartient bien à l'utilisateur
    db_device = db.query(Device).filter(
        Device.id == device_id,
        Device.owner_id == current_user.id
    ).first()

    if not db_device:
        raise HTTPException(status_code=404, detail="Device not found or not owned by user.")

    # 2. On vérifie si le nouveau nom n'est pas déjà pris par un AUTRE appareil
    if device_data.name != db_device.name:
        existing_device = db.query(Device).filter(
            Device.name == device_data.name,
            Device.owner_id == current_user.id
        ).first()
        if existing_device:
            raise HTTPException(status_code=400, detail=f"A device with the name '{device_data.name}' already exists.")

    # 3. On met à jour les champs de l'objet
    update_data = device_data.model_dump(exclude_unset=True)
    for key, value in update_data.items():
        setattr(db_device, key, value)
    
    db.commit()
    db.refresh(db_device)
    
    return db_device


# Dashboard / attacks
# Dans backend/main.py

@app.get("/api/dashboard/stats", response_model=DashboardStats)
def get_user_dashboard_stats(current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    """
    Renvoie les statistiques UNIQUEMENT pour les appareils de l'utilisateur connecté.
    """
    # 1. Obtenir la liste des clés API de l'utilisateur
    user_device_keys = [d.api_key for d in current_user.devices]
    
    # Si l'utilisateur n'a pas d'appareils, on renvoie des stats vides
    if not user_device_keys:
        return DashboardStats(device_count=0, attacks_this_week=0, last_attack_timestamp=None)

    # 2. Filtrer les requêtes de statistiques par ces clés
    seven_days_ago = datetime.utcnow() - timedelta(days=7)
    
    attacks_count = db.query(AttackLog).filter(
        AttackLog.device_api_key.in_(user_device_keys),
        AttackLog.timestamp >= seven_days_ago
    ).count()
    
    last_attack = db.query(AttackLog).filter(
        AttackLog.device_api_key.in_(user_device_keys)
    ).order_by(AttackLog.timestamp.desc()).first()

    return DashboardStats(
        device_count=len(user_device_keys),
        attacks_this_week=attacks_count,
        last_attack_timestamp=last_attack.timestamp if last_attack else None
    )
@app.get("/api/attacks/history", response_model=List[AttackLogPublic])
def get_attack_history(
    current_user: User = Depends(get_current_user), 
    db: Session = Depends(get_db)
):
    """
    Renvoie l'historique des attaques DÉTECTÉES PAR LES APPAREILS DE L'UTILISATEUR.
    """
    # 1. Obtenir la liste des clés API de l'utilisateur
    user_device_keys = [d.api_key for d in current_user.devices]
    
    if not user_device_keys:
        return [] # Si l'utilisateur n'a pas d'appareils, il n'a pas d'historique

    # 2. Filtrer les logs d'attaques par ces clés
    return db.query(AttackLog).filter(
        AttackLog.device_api_key.in_(user_device_keys)
    ).order_by(AttackLog.timestamp.desc()).limit(50).all()

@app.post("/api/attacks/report", response_model=AttackLogPublic)
async def report_attack(report: AttackReport, db: Session = Depends(get_db)):
    lat, lon, city, country = enrich_geoip(report.source_ip)
    new_log = AttackLog(
        source_ip=report.source_ip,
        attack_type=report.attack_type,
        confidence=report.confidence,
        device_api_key=report.api_key,
        latitude=lat,
        longitude=lon,
        city=city,
        country=country,
    )
    db.add(new_log)
    db.commit()
    db.refresh(new_log)
    await manager.broadcast(json.dumps(log_to_json_serializable(new_log)), "attacks")
    await send_ntfy_notification(new_log)
    return new_log

# Dans main.py

@app.post("/api/fl_update")
async def fl_update(status: FLStatus):
    print(f"➡️  [WebSocket] Received FL update: {status.model_dump_json()}")
    print(f"   -> Broadcasting to {len(manager.channels.get('fl_status', []))} connected clients...")
    await manager.broadcast(status.model_dump_json(), "fl_status")
    print("   -> ✅ Broadcast complete.")
    return {"status": "broadcasted"}


# Admin
@app.get("/api/admin/dashboard", response_model=DashboardStats)
def get_dashboard(current_user: User = Depends(get_current_admin_user), db: Session = Depends(get_db)):
    count = db.query(Device).count()
    attacks = db.query(AttackLog).filter(AttackLog.timestamp > datetime.utcnow() - timedelta(days=7)).count()
    last = db.query(AttackLog).order_by(AttackLog.timestamp.desc()).first()
    return DashboardStats(device_count=count, attacks_this_week=attacks, last_attack_timestamp=last.timestamp if last else None)

# Dans backend/main.py

from sqlalchemy import func # Assurez-vous d'avoir cet import

# On peut réutiliser le Pydantic Model `ClientModel`

# === LE NOUVEL ENDPOINT EST ICI ===
@app.get("/api/admin/clients/top-performing", response_model=List[ClientModel], dependencies=[Depends(get_current_admin_user)])
def get_top_performing_clients(db: Session = Depends(get_db)):
    """
    Calcule et renvoie les 3 clients avec la meilleure accuracy moyenne.
    """
    # C'est une requête SQL complexe traduite en SQLAlchemy :
    # 1. On joint les tables Client et ClientHistory.
    # 2. On groupe les résultats par client.
    # 3. On calcule l'accuracy moyenne pour chaque client.
    # 4. On ordonne les résultats par cette moyenne, en ordre décroissant.
    # 5. On ne prend que les 3 premiers.
    top_clients_query = db.query(
        Client,
        func.avg(ClientHistory.accuracy).label('avg_accuracy')
    ).join(Client.history_records).group_by(Client.id).order_by(
        func.avg(ClientHistory.accuracy).desc()
    ).limit(3).all()

    # La requête renvoie une liste de tuples (Client, avg_accuracy).
    # On ne veut renvoyer que les objets Client.
    top_clients = [client for client, avg_accuracy in top_clients_query]
    
    return top_clients
@app.get("/api/admin/clients", response_model=List[ClientAdminView], dependencies=[Depends(get_current_admin_user)])
def get_admin_clients(db: Session = Depends(get_db)):
    """
    Récupère tous les clients FL et pré-charge les informations de leur propriétaire.
    """
    # === LA CORRECTION EST ICI ===
    # On fait une seule requête qui récupère les clients ET leurs propriétaires
    clients = db.query(Client).options(selectinload(Client.owner)).all()
    
    response = []
    for client in clients:
        # On utilise la validation Pydantic pour construire la réponse
        client_data = ClientAdminView.model_validate(client)
        if client.owner:
            client_data.owner_username = client.owner.username
            client_data.owner_email = client.owner.email
        response.append(client_data)
        
    return response
@app.get("/api/admin/clients/{client_id}/history", response_model=List[HistoryModel], dependencies=[Depends(get_current_admin_user)])
def get_client_history(client_id: int, db: Session = Depends(get_db)):
    history = db.query(ClientHistory).filter(ClientHistory.client_id == client_id).order_by(ClientHistory.server_round.asc()).all()
    return history



@app.get("/api/admin/attacks/history", response_model=List[AttackLogPublic], dependencies=[Depends(get_current_admin_user)])
def get_global_attack_history(db: Session = Depends(get_db)):
    return db.query(AttackLog).order_by(AttackLog.timestamp.desc()).limit(200).all()


@app.post("/api/admin/client_history")
def save_client_history(
    history_payload: List[ClientHistoryPayload],
    db: Session = Depends(get_db),
):
    for record in history_payload:
        client = db.query(Client).filter(Client.flower_id == record.client_flower_id).first()
        if not client:
            client = Client(flower_id=record.client_flower_id, name=f"Client_{record.client_flower_id[:6]}")
            db.add(client)
            db.commit()
            db.refresh(client)
        history_entry = ClientHistory(
            client_id=client.id,
            server_round=record.server_round,
            accuracy=record.accuracy,
            loss=record.loss,
        )
        db.add(history_entry)
    db.commit()
    return {"status": "history saved"}


@app.get("/api/admin/stats", response_model=AdminStats, dependencies=[Depends(get_current_admin_user)])
def get_admin_stats(db: Session = Depends(get_db)):
    twenty_four_hours_ago = datetime.utcnow() - timedelta(hours=24)
    stats = AdminStats(
        total_users=db.query(User).count(),
        premium_users=db.query(User).filter(User.role == "premium").count(),
        total_devices=db.query(Device).count(),
        online_devices=db.query(DeviceStatus).filter(DeviceStatus.status == "online").count(),
        total_attacks_24h=db.query(AttackLog).filter(AttackLog.timestamp >= twenty_four_hours_ago).count(),
    )
    return stats


@app.get("/api/admin/users", response_model=List[UserAdminView], dependencies=[Depends(get_current_admin_user)])
def get_all_users_for_admin(db: Session = Depends(get_db)):
    users = db.query(User).options(selectinload(User.devices)).all()
    response = []
    for user in users:
        prevention_on_count = sum(1 for device in user.devices if device.prevention_enabled)
        payment_count = db.query(Payment).filter(Payment.user_id == user.id, Payment.status == "succeeded").count()
        user_dict = UserPublic.model_validate(user).model_dump()
        user_dict["device_count"] = len(user.devices)
        user_dict["devices_with_prevention_on"] = prevention_on_count
        user_dict["payment_count"] = payment_count
        user_data = UserAdminView.model_validate(user_dict)
        response.append(user_data)
    return response
@app.put("/api/admin/users/{user_id}/status", response_model=UserPublic, dependencies=[Depends(get_current_admin_user)])
def toggle_user_status(user_id: int, db: Session = Depends(get_db)):
    """
    Inverse le statut 'is_active' d'un utilisateur (suspendre/réactiver).
    Protégé pour les administrateurs uniquement.
    """
    user = db.query(User).filter(User.id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    
    # On ne peut pas désactiver le super-admin
    if user.role == "admin":
        raise HTTPException(status_code=403, detail="Cannot change the status of an admin account.")
        
    # Inverser la valeur actuelle
    user.is_active = not user.is_active
    db.commit()
    db.refresh(user)
    
    print(f"Admin action: User '{user.username}' status set to {user.is_active}")
    return user


@app.get("/api/admin/fl-global-history", response_model=List[GlobalRoundHistory], dependencies=[Depends(get_current_admin_user)])
def get_fl_global_history(db: Session = Depends(get_db)):
    """
    Récupère et agrège l'historique de performance global, round par round.
    """
    # C'est une requête SQL complexe traduite en SQLAlchemy :
    # On groupe les entrées de ClientHistory par numéro de round.
    # Pour chaque round, on calcule la moyenne de l'accuracy et de la loss.
    # On prend aussi le timestamp le plus récent pour ce round.
    history = (
        db.query(
            ClientHistory.server_round,
            func.avg(ClientHistory.accuracy).label("accuracy"),
            func.avg(ClientHistory.loss).label("loss"),
            func.max(ClientHistory.timestamp).label("timestamp"),
        )
        .group_by(ClientHistory.server_round)
        .order_by(ClientHistory.server_round.asc())
        .all()
    )
    
    # La requête renvoie des tuples, on les convertit en objets Pydantic
    return [GlobalRoundHistory(server_round=r[0], accuracy=r[1], loss=r[2], timestamp=r[3]) for r in history]


@app.get("/api/admin/fl-history", response_model=List[FLRoundHistory], dependencies=[Depends(get_current_admin_user)])
def get_fl_history(db: Session = Depends(get_db)):
    """Récupère l'historique global des rounds d'entraînement."""
    # Note: Pour une vraie agrégation, il faudrait une requête plus complexe.
    # Pour la simulation, on prend l'historique du premier client trouvé.
    history = db.query(ClientHistory).order_by(ClientHistory.server_round.asc()).limit(100).all()
    return history
# Dans backend/main.py

@app.get("/api/admin/analysis-history", response_model=List[AnalysisHistoryPublic], dependencies=[Depends(get_current_admin_user)])
def get_analysis_history(db: Session = Depends(get_db)):
    """Récupère la liste des analyses de modèle passées."""
    return db.query(AnalysisHistory).order_by(AnalysisHistory.timestamp.desc()).limit(20).all()

@app.get("/api/admin/analysis-history/{history_id}", response_model=EvaluationResult, dependencies=[Depends(get_current_admin_user)])
def get_analysis_result(history_id: int, db: Session = Depends(get_db)):
    """Récupère le résultat complet (rapport + matrice) d'une analyse spécifique."""
    analysis = db.query(AnalysisHistory).filter(AnalysisHistory.id == history_id).first()
    if not analysis:
        raise HTTPException(status_code=404, detail="Analysis not found")
    
    return {
        "report": json.loads(analysis.classification_report), # On reconvertit la chaîne JSON en dict
        "confusion_matrix_b64": analysis.confusion_matrix_b64
    }
@app.post("/api/admin/evaluate-model", response_model=EvaluationResult, dependencies=[Depends(get_current_admin_user)])
async def evaluate_model(
    # === LA CORRECTION EST ICI ===
    # On ajoute current_user comme paramètre pour pouvoir l'utiliser
    current_user: User = Depends(get_current_admin_user), 
    file: UploadFile = File(...), 
    db: Session = Depends(get_db)
):
    
    try:
        model = create_model()
        model.load_weights("global_model.weights.h5")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Could not load model: {e}")

    try:
        contents = await file.read()
        df = pd.read_csv(io.BytesIO(contents))
        
        if df.empty:
            raise HTTPException(status_code=400, detail="CSV is empty or improperly formatted.")
    
        feature_columns = df.columns[:-1].tolist()
        label_column = df.columns[-1]
        
        if len(feature_columns) != 7: # NUM_FEATURES
            raise HTTPException(status_code=400, detail=f"Model expects 7 features, but CSV has {len(feature_columns)}.")

        # === LA CORRECTION EST ICI ===
        # 1. Définir la liste complète de toutes les classes que le modèle connaît
        ALL_ATTACK_LABELS = [
            'Backdoor', 'DDoS_HTTP', 'DDoS_ICMP', 'DDoS_TCP', 'DDoS_UDP',
            'Fingerprinting', 'MITM', 'Normal', 'Password', 'Port_Scanning',
            'Ransomware', 'SQL_injection', 'Uploading', 'Vulnerability_scanner', 'XSS'
        ]
        
        # 2. Prétraiter les features
        scaler = MinMaxScaler()
        X_scaled = scaler.fit_transform(df[feature_columns])
        
        # 3. Prétraiter les labels de manière robuste
        encoder = LabelEncoder()
        # On "entraîne" l'encodeur sur TOUTES les classes possibles
        encoder.fit(ALL_ATTACK_LABELS)
        
        # On vérifie que les labels du fichier de test sont connus
        unknown_labels = set(df[label_column]) - set(encoder.classes_)
        if unknown_labels:
            raise HTTPException(status_code=400, detail=f"CSV contains unknown labels: {list(unknown_labels)}")
            
        # On transforme les labels du fichier de test
        y_encoded = encoder.transform(df[label_column])
        
        # 4. Créer les séquences
        X_test, y_test = create_sequences_for_evaluation(X_scaled, y_encoded)
        
    except HTTPException as e:
        raise e # On propage les erreurs HTTP spécifiques
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error processing CSV file: {e}")

    # Prédictions et rapports
    predictions_proba = model.predict(X_test)
    predictions = np.argmax(predictions_proba, axis=1)
    
    # On utilise la liste complète des labels pour le rapport
    report = classification_report(y_test, predictions, labels=range(len(ALL_ATTACK_LABELS)), target_names=ALL_ATTACK_LABELS, output_dict=True)
    cm = confusion_matrix(y_test, predictions, labels=range(len(ALL_ATTACK_LABELS)))

    # Création de l'image de la matrice de confusion
    fig, ax = plt.subplots(figsize=(12, 10))
    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', 
                xticklabels=ALL_ATTACK_LABELS, yticklabels=ALL_ATTACK_LABELS, ax=ax)
    plt.xticks(rotation=45, ha='right')
    plt.yticks(rotation=0)
    ax.set_xlabel('Predicted Labels')
    ax.set_ylabel('True Labels')
    ax.set_title('Confusion Matrix')
    
    buf = io.BytesIO()
    plt.savefig(buf, format='png', bbox_inches='tight')
    buf.seek(0)
    img_b64 = base64.b64encode(buf.read()).decode('utf-8')
    plt.close(fig)
    new_analysis = AnalysisHistory(
        filename=file.filename,
        classification_report=json.dumps(report), # On convertit le dict en chaîne JSON
        confusion_matrix_b64=img_b64,
        admin_id=current_user.id # On suppose que get_current_admin_user est utilisé
    )
    db.add(new_analysis)
    db.commit()
    
    # 2. Renvoyer le résultat comme avant
    return {"report": report, "confusion_matrix_b64": img_b64}



@app.get("/api/admin/users/{user_id}", response_model=UserAdminView, dependencies=[Depends(get_current_admin_user)])
def get_user_details_for_admin(user_id: int, db: Session = Depends(get_db)):
    user = db.query(User).filter(User.id == user_id).options(selectinload(User.devices)).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
        
    # On réutilise la même logique d'enrichissement que pour la liste
    prevention_on_count = sum(1 for device in user.devices if device.prevention_enabled)
    payment_count = db.query(Payment).filter(Payment.user_id == user.id, Payment.status == 'succeeded').count()
    
    user_dict = UserPublic.model_validate(user).model_dump()
    user_dict['device_count'] = len(user.devices)
    user_dict['devices_with_prevention_on'] = prevention_on_count
    user_dict['payment_count'] = payment_count
    
    return UserAdminView.model_validate(user_dict)
@app.get("/api/admin/users/{user_id}/devices", response_model=List[DeviceWithStatus], dependencies=[Depends(get_current_admin_user)])
def get_user_devices_for_admin(user_id: int, db: Session = Depends(get_db)):
    """
    Récupère la liste de tous les appareils appartenant à un utilisateur spécifique.
    """
    user = db.query(User).filter(User.id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")

 
    response = []
    for d in user.devices:
        status_obj = db.query(DeviceStatus).filter_by(device_api_key=d.api_key).first()
        device_data = DeviceWithStatus.model_validate(d, context={'status_info': status_obj})
        response.append(device_data)
        
    return response


FLOWER_PROCESS = None

@app.post("/api/admin/training/start", response_model=TrainingStatus, dependencies=[Depends(get_current_admin_user)])
def start_training():
    """
    Démarre le script server.py en tant que processus en arrière-plan.
    """
    global FLOWER_PROCESS
    
    # Vérifier si un processus est déjà en cours
    if FLOWER_PROCESS and FLOWER_PROCESS.poll() is None:
        raise HTTPException(status_code=409, detail="A training session is already in progress.")

    print("🚀 Admin requested to start a new training session...")
    
    # On utilise sys.executable pour être sûr d'utiliser le même interpréteur Python
    # que celui qui exécute uvicorn (celui du venv)
    command = [sys.executable, "server.py", "--num-clients", "1"]
    
    # === LA CORRECTION EST ICI ===
    # On ne redirige plus stdout/stderr, on les laisse s'afficher
    # dans la console parente (celle de uvicorn).
    FLOWER_PROCESS = subprocess.Popen(command)
    
    print(f"✅ Flower server process started with PID: {FLOWER_PROCESS.pid}")
    
    return TrainingStatus(is_running=True, pid=FLOWER_PROCESS.pid)

@app.post("/api/admin/training/stop", response_model=TrainingStatus, dependencies=[Depends(get_current_admin_user)])
def stop_training():
    """
    Arrête le processus server.py en cours.
    """
    global FLOWER_PROCESS
    
    if FLOWER_PROCESS and FLOWER_PROCESS.poll() is None:
        print(f"🛑 Admin requested to stop training session (PID: {FLOWER_PROCESS.pid})...")
        FLOWER_PROCESS.terminate() # Envoie un signal pour arrêter proprement
        try:
            FLOWER_PROCESS.wait(timeout=5) # Attendre 5 secondes que le processus se termine
        except subprocess.TimeoutExpired:
            FLOWER_PROCESS.kill() # Si ce n'est pas suffisant, on le force
        print("✅ Training session stopped.")
        FLOWER_PROCESS = None
        return TrainingStatus(is_running=False)
        
    raise HTTPException(status_code=404, detail="No active training session to stop.")

@app.get("/api/admin/training/status", response_model=TrainingStatus, dependencies=[Depends(get_current_admin_user)])
def get_training_status():
    """
    Vérifie si le processus server.py est actuellement en cours d'exécution.
    """
    global FLOWER_PROCESS
    
    if FLOWER_PROCESS and FLOWER_PROCESS.poll() is None:
        # poll() renvoie None si le processus est toujours en cours
        return TrainingStatus(is_running=True, pid=FLOWER_PROCESS.pid)
    
    return TrainingStatus(is_running=False)

@app.post("/api/auth/register", response_model=UserPublic)
async def register(user_in: UserCreate, background_tasks: BackgroundTasks, db: Session = Depends(get_db)):
    if db.query(User).filter((User.email == user_in.email) | (User.username == user_in.username)).first():
        raise HTTPException(status_code=400, detail="Email or username already used")
    
    code = f"{random.randint(100000, 999999)}"
    
    # On utilise les nouveaux champs du modèle UserCreate
    user = User(
        email=user_in.email,
        username=user_in.username,
        hashed_password=get_password_hash(user_in.password),
        full_name=user_in.full_name,
        company=user_in.company,
        country=user_in.country,
        verification_code=code,
        is_active=False
    )
    db.add(user)
    db.commit()
    db.refresh(user)

    try:
        fm = FastMail(mail_conf)
        msg = MessageSchema(
            subject="FedIds - Activate Your Account",
            recipients=[user.email],
            body=f"<p>Your verification code is <b>{code}</b></p>",
            subtype="html",
        )
        background_tasks.add_task(fm.send_message, msg)
    except Exception as e:
        # non-fatal
        print("Email send error:", e)

    return UserPublic.model_validate(user)

@app.get("/api/admin/attacks/stats-by-type", response_model=List[AttackTypeStat], dependencies=[Depends(get_current_admin_user)])
def get_attack_stats_by_type(db: Session = Depends(get_db)):
    stats = db.query(
        AttackLog.attack_type,
        func.count(AttackLog.id).label("count")
    ).group_by(AttackLog.attack_type).order_by(func.count(AttackLog.id).desc()).all()
    return stats
# Flower registration
# Dans main.py

@app.post("/api/fl/register")
def fl_register(payload: FLClientRegistration, db: Session = Depends(get_db)):
    device = db.query(Device).filter_by(api_key=payload.api_key).first()
    if not device or not device.owner:
        raise HTTPException(status_code=404, detail="Device or owner not found for the given API key.")

    client = db.query(Client).filter_by(flower_id=payload.flower_cid).first()
    if not client:
        client = Client(
            flower_id=payload.flower_cid,
            name=device.name,
            owner_id=device.owner.id
        )
        db.add(client)
    else:
        client.owner_id = device.owner.id
        client.name = device.name
    
    db.commit()
    return {"status": "registered"}

# Sequence helper for evaluation
def create_sequences_for_evaluation(X, y, time_steps=20):
    Xs, ys = [], []
    for i in range(len(X) - time_steps):
        Xs.append(X[i : (i + time_steps)])
        ys.append(y[i + time_steps])
    return np.array(Xs), np.array(ys)




# Websockets
async def get_user_from_ws_token(websocket: WebSocket, db: Session = Depends(get_db)) -> Optional[User]:
    try:
        token = websocket.query_params.get("token")
        if not token:
            await websocket.close(code=http_status.WS_1008_POLICY_VIOLATION)
            return None
        return await get_current_user(token, db)
    except Exception:
        await websocket.close(code=http_status.WS_1008_POLICY_VIOLATION)
        return None


@app.websocket("/ws/attacks")
async def websocket_attacks(websocket: WebSocket, db: Session = Depends(get_db)):
    user = await get_user_from_ws_token(websocket, db)
    if not user:
        return
    await manager.connect(websocket, "attacks")
    try:
        while True:
            await websocket.receive_text()
    except WebSocketDisconnect:
        manager.disconnect(websocket, "attacks")

@app.websocket("/ws/fl_status")
async def websocket_fl_status(websocket: WebSocket, db: Session = Depends(get_db)):
    # On utilise le helper que nous avions déjà créé
    user = await get_user_from_ws_token(websocket, db)
    if not user:
        # Si le token est invalide ou manquant, on refuse la connexion
        return

    await manager.connect(websocket, "fl_status")
    try:
        while True:
            await websocket.receive_text() # Garde la connexion ouverte
    except WebSocketDisconnect:
        manager.disconnect(websocket, "fl_s tatus")


# Google OAuth
@app.get("/api/auth/google", include_in_schema=False)
async def login_via_google(request: Request):
    redirect_uri = request.url_for("auth_via_google_callback")
    return await oauth.google.authorize_redirect(request, redirect_uri)


@app.get("/api/auth/google/callback", include_in_schema=False)
async def auth_via_google_callback(request: Request, db: Session = Depends(get_db)):
    frontend_login_url = f"{FRONTEND_BASE}/login"
    try:
        token = await oauth.google.authorize_access_token(request)
    except Exception as e:
        print(f"Error authorizing Google token: {e}")
        return RedirectResponse(url=f"{frontend_login_url}?error=google_auth_failed")

    user_info = token.get("userinfo") or token.get("id_token_claims")
    if not user_info or not user_info.get("sub") or not user_info.get("email"):
        return RedirectResponse(url=f"{frontend_login_url}?error=google_info_missing")

    google_id = user_info["sub"]
    email = user_info["email"]
    user = db.query(User).filter(User.google_id == google_id).first()
    if not user:
        user = db.query(User).filter(User.email == email).first()
        if user:
            user.google_id = google_id
            user.is_active = True
        else:
            base_username = email.split("@")[0].replace('.', '_')
            final_username = base_username
            while db.query(User).filter(User.username == final_username).first():
                final_username = f"{base_username}_{uuid.uuid4().hex[:4]}"
            user = User(email=email, google_id=google_id, username=final_username, is_active=True, role="user")
            db.add(user)
        db.commit()
        db.refresh(user)

    access_token = create_access_token(data={"sub": user.username})
    frontend_callback_url = f"{FRONTEND_BASE}/auth/callback"
    user_data_for_frontend = UserPublic.model_validate(user).model_dump_json()
    params = urlencode({"token": access_token, "user": user_data_for_frontend})
    return RedirectResponse(url=f"{frontend_callback_url}?{params}")


# Payments
@app.post("/api/payments/create-payment-intent")
def create_payment(user: User = Depends(get_current_user)):
    try:
        intent = stripe.PaymentIntent.create(
            amount=PREMIUM_PLAN_PRICE,
            currency='eur',
            automatic_payment_methods={'enabled': True},
            metadata={'user_id': user.id},
        )
        return {'clientSecret': intent.client_secret}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/api/payments/webhook")
async def stripe_webhook(request: Request, db: Session = Depends(get_db)):
    payload = await request.body()
    sig_header = request.headers.get('stripe-signature')
    endpoint_secret = os.getenv("STRIPE_WEBHOOK_SECRET")
    try:
        event = stripe.Webhook.construct_event(payload, sig_header, endpoint_secret)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Webhook error: {e}")

    if event['type'] == 'payment_intent.succeeded':
        intent = event['data']['object']
        user_id = intent['metadata'].get('user_id')
        if user_id:
            user = db.query(User).filter(User.id == int(user_id)).first()
            if user and user.role != 'premium':
                user.role = 'premium'
                user.subscription_valid_until = datetime.utcnow() + timedelta(days=30)
                db.commit()
    elif event['type'] == 'payment_intent.payment_failed':
        intent = event['data']['object']
        user_id = intent['metadata'].get('user_id')
        print(f"❌ Webhook FAILED: Payment failed for user ID {user_id}.")

    return {"status": "success"}



# --- TICKETS (ADMIN) ---

def analyze_ticket_content(subject: str, message: str) -> Tuple[str, str]:
    """
    Analyse le contenu d'un ticket pour déterminer sa priorité.
    """
    text = (subject + " " + message).lower()
    
    # === LA LOGIQUE DE PRIORITÉ AMÉLIORÉE EST ICI ===

    # 1. On cherche d'abord les mots-clés les plus critiques
    critical_keywords = ["urgent", "critical", "down", "outage", "cannot work", "production stop"]
    if any(keyword in text for keyword in critical_keywords):
        priority = "critical"
        return priority # On s'arrête ici si c'est critique

    # 2. Ensuite, les mots-clés de haute priorité
    high_keywords = ["billing", "payment", "invoice", "security issue", "vulnerability"]
    if any(keyword in text for keyword in high_keywords):
        priority = "high"
        return priority

    # 3. Ensuite, les mots-clés de priorité moyenne
    medium_keywords = ["bug", "error", "not working", "problem", "issue"]
    if any(keyword in text for keyword in medium_keywords):
        priority = "medium"
        return priority
        
    # 4. Si aucun mot-clé correspondant n'est trouvé, la priorité est basse
    # C'est le cas pour les questions générales, les demandes de fonctionnalités, etc.
    priority = "low"
        
    return priority


# Endpoint pour créer un ticket (utilisé par l'utilisateur)
# Dans main.py

@app.post("/api/tickets", status_code=201)
def create_ticket(ticket_data: TicketCreate, current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    print("--- 1. Début de la création du ticket ---")
    priority = analyze_ticket_content(ticket_data.subject, ticket_data.message)
    
    new_ticket = Ticket(
        user_id=current_user.id,
        subject=ticket_data.subject,
        category=ticket_data.category, # On utilise la catégorie fournie
        priority=priority
    )
    db.add(new_ticket)
    print("--- 2. Ticket ajouté à la session SQLAlchemy ---")
    
    try:
        db.commit()
        print("--- 3. COMMIT RÉUSSI pour le ticket ---")
        db.refresh(new_ticket)
        
        initial_message = TicketMessage(
            ticket_id=new_ticket.id,
            author_id=current_user.id,
            message=ticket_data.message
        )
        db.add(initial_message)
        print("--- 4. Message ajouté à la session ---")
        
        db.commit()
        print("--- 5. COMMIT RÉUSSI pour le message ---")
        
        return new_ticket
        
    except Exception as e:
        print(f"❌ ERREUR PENDANT LE COMMIT : {e}")
        db.rollback() # Annuler la transaction en cas d'erreur
        raise HTTPException(status_code=500, detail="Database error occurred.")

# Endpoint pour qu'un utilisateur voie ses propres tickets
@app.get("/api/tickets/my-tickets")
def get_my_tickets(current_user: User = Depends(get_current_user)):
    return current_user.tickets

# Endpoint pour qu'un admin voie TOUS les tickets
@app.get("/api/admin/tickets", dependencies=[Depends(get_current_admin_user)])
def get_all_tickets(db: Session = Depends(get_db)):
    # === LA CORRECTION EST ICI ===
    # On utilise .options(joinedload(Ticket.user)) pour forcer le chargement
    # de la relation 'user' en même temps que les tickets.
    return db.query(Ticket).options(joinedload(Ticket.user)).order_by(Ticket.updated_at.desc()).all()

# Endpoint pour voir les détails d'un ticket (messages inclus)

@app.get("/api/tickets/{ticket_id}")
def get_ticket_details(ticket_id: int, current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    # === LA CORRECTION EST ICI ===
    # On utilise un joinedload "chaîné" pour charger les messages ET l'auteur de chaque message.
    ticket = db.query(Ticket).options(
        joinedload(Ticket.messages).joinedload(TicketMessage.author)
    ).filter(Ticket.id == ticket_id).first()
    
    # Vérifier que l'utilisateur a le droit de voir ce ticket
    if not ticket or (ticket.user_id != current_user.id and current_user.role != 'admin'):
        raise HTTPException(status_code=404, detail="Ticket not found")
        
    return ticket
@app.post("/api/tickets/{ticket_id}/close", status_code=200)
def close_ticket(
    ticket_id: int, 
    current_user: User = Depends(get_current_user), 
    db: Session = Depends(get_db)
):
    """
    Permet à un admin de clore n'importe quel ticket.
    (On pourrait aussi autoriser l'utilisateur, mais on se concentre sur le besoin de l'admin).
    """
    ticket = db.query(Ticket).filter(Ticket.id == ticket_id).first()
    
    # === LA LOGIQUE DE PERMISSION CORRIGÉE ===
    # On vérifie d'abord si le ticket existe
    if not ticket:
        raise HTTPException(status_code=404, detail="Ticket not found.")
        
    # Ensuite, on vérifie si l'utilisateur est un admin
    if current_user.role != 'admin':
        raise HTTPException(status_code=403, detail="You do not have permission to close this ticket.")
        
    if ticket.status == 'closed':
        raise HTTPException(status_code=400, detail="Ticket is already closed.")

    ticket.status = "closed"
    ticket.updated_at = datetime.utcnow()
    db.commit()
    
    return {"message": "Ticket has been closed successfully by admin."}
# Endpoint pour répondre à un ticket
@app.post("/api/tickets/{ticket_id}/reply")
def reply_to_ticket(
    ticket_id: int, 
    message_data: TicketMessageCreate, 
    background_tasks: BackgroundTasks, # <-- Ajouté pour les emails
    current_user: User = Depends(get_current_user), 
    db: Session = Depends(get_db)
):
    ticket = db.query(Ticket).options(joinedload(Ticket.user)).filter(Ticket.id == ticket_id).first()
    
    # Vérifier les permissions
    if not ticket or (ticket.user_id != current_user.id and current_user.role != 'admin'):
        raise HTTPException(status_code=404, detail="Ticket not found")

    # Créer le nouveau message
    new_message = TicketMessage(
        ticket_id=ticket.id,
        author_id=current_user.id,
        message=message_data.message
    )
    db.add(new_message)
    
    # Mettre à jour le statut et la date du ticket
    if current_user.role == 'admin':
        ticket.status = "pending_user" # L'admin a répondu, en attente de l'utilisateur
        
        # === NOTIFICATION PAR EMAIL ===
        user_to_notify = ticket.user
        fm = FastMail(mail_conf)
        msg = MessageSchema(
            subject=f"Re: Your ticket #{ticket.id} - {ticket.subject}",
            recipients=[user_to_notify.email],
            body=f"<p>A support agent has replied to your ticket. Please log in to view the response.</p>",
            subtype="html"
        )
        background_tasks.add_task(fm.send_message, msg)
        
    else: # C'est un utilisateur qui répond
        ticket.status = "pending_admin"
    
    ticket.updated_at = datetime.utcnow()
    
    db.commit()
    db.refresh(new_message)
    return new_message


# Ajoutez ce nouvel endpoint (pour l'admin)
@app.get("/api/admin/tickets/stats", response_model=List[TicketCategoryStat], dependencies=[Depends(get_current_admin_user)])
def get_ticket_category_stats(db: Session = Depends(get_db)):
    """
    Compte le nombre de tickets par catégorie.
    """
    stats = db.query(
        Ticket.category,
        func.count(Ticket.id).label("count")
    ).group_by(Ticket.category).all()
    
    # Le résultat est une liste de tuples, on le convertit en liste de dictionnaires
    return [{"category": category, "count": count} for category, count in stats]
@app.delete("/api/tickets/{ticket_id}", status_code=http_status.HTTP_204_NO_CONTENT)
def delete_ticket(
    ticket_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Supprime un ticket.
    - L'utilisateur doit être le propriétaire du ticket ou un admin.
    - Le ticket doit avoir le statut 'closed'.
    """
    ticket = db.query(Ticket).filter(Ticket.id == ticket_id).first()

    # 1. Vérifier si le ticket existe
    if not ticket:
        raise HTTPException(status_code=404, detail="Ticket not found.")

    # 2. Vérifier les permissions (propriétaire ou admin)
    if ticket.user_id != current_user.id and current_user.role != 'admin':
        raise HTTPException(status_code=403, detail="You do not have permission to delete this ticket.")

    # 3. Vérifier si le ticket est bien clos
    if ticket.status != 'closed':
        # On renvoie une erreur 400 (Bad Request) avec un message clair
        raise HTTPException(status_code=400, detail="This ticket is not closed yet. Please wait for an admin to resolve it.")

    # 4. Si tout est bon, on supprime
    db.delete(ticket)
    db.commit()
    
    return Response(status_code=http_status.HTTP_204_NO_CONTENT)



@app.post("/api/admin/tickets/{ticket_id}/assign", dependencies=[Depends(get_current_admin_user)])
def assign_ticket(ticket_id: int, current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    ticket = db.query(Ticket).filter(Ticket.id == ticket_id).first()
    if not ticket: raise HTTPException(404, "Ticket not found")
    
    ticket.assigned_admin_id = current_user.id
    ticket.status = "in_progress"
    db.commit()
    return {"message": f"Ticket assigned to {current_user.username}"}

@app.get("/api/faq/search")
def search_faq(query: str, db: Session = Depends(get_db)):
    """
    Recherche simple par mots-clés dans la base de connaissances.
    """
    return db.query(FaqArticle).filter(FaqArticle.keywords.contains(query.lower())).all()

@app.post("/api/auth/forgot-password")
async def forgot_password(req: ForgotPasswordRequest, background_tasks: BackgroundTasks, db: Session = Depends(get_db)):
    user = db.query(User).filter(User.email == req.email).first()
    
    # Pour des raisons de sécurité, on ne révèle jamais si l'email existe ou non.
    # On renvoie toujours un message de succès.
    if user:
        # Générer un token sécurisé
        token = secrets.token_hex(20)
        user.password_reset_token = token
        user.password_reset_expires = datetime.utcnow() + timedelta(hours=1) # Valide 1 heure
        db.commit()
        
        # Envoyer l'email en arrière-plan
        reset_link = f"http://localhost:5173/reset-password?token={token}"
        fm = FastMail(mail_conf)
        msg = MessageSchema(subject="FedIds - Reset Your Password", recipients=[user.email],
                            body=f"<p>Click here to reset your password: <a href='{reset_link}'>{reset_link}</a></p>", subtype="html")
        background_tasks.add_task(fm.send_message, msg)
        
    return {"message": "If an account with this email exists, a password reset link has been sent."}

@app.post("/api/auth/reset-password")
def reset_password(req: ResetPasswordRequest, db: Session = Depends(get_db)):
    user = db.query(User).filter(User.password_reset_token == req.token).first()
    
    if not user or user.password_reset_expires < datetime.utcnow():
        raise HTTPException(status_code=400, detail="Invalid or expired token.")
        
    user.hashed_password = get_password_hash(req.new_password)
    user.password_reset_token = None # Invalider le token après utilisation
    user.password_reset_expires = None
    db.commit()
    
    return {"message": "Password has been reset successfully."}
# Dans backend/main.py
# Dans backend/main.py

@app.post("/api/chatbot/query", response_model=ChatResponse, dependencies=[Depends(get_current_user)])
async def handle_chat_query(query: ChatQuery, user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    if user.role != 'premium':
        raise HTTPException(status_code=403, detail="Chatbot is a premium feature.")

    new_log = ChatLog(user_id=user.id, question=query.question.strip().lower())
    db.add(new_log)
    db.commit()

    try:
        model = genai.GenerativeModel('gemini-pro-latest')
        
        # === LA CORRECTION EST ICI ===
        # On supprime la ligne en double
        chat_session = model.start_chat(
            history=[
                {
                    "role": "user",
                    "parts": [
                        """
                        **System Instructions:**
                        You are "FedIds Assist", an expert AI assistant for the "FedIds" security platform.
                        Your tone is helpful, professional, and very concise.
                        You MUST follow these rules:
                        1.  **Be Brief:** Use short sentences. Use bullet points whenever possible. Do not write long paragraphs.
                        2.  **Stay Focused:** Your knowledge is strictly limited to these topics:
                            -   **Federated Learning (FL):** A privacy-first ML method where models train on devices without data leaving. Only model updates are shared.
                            -   **Our Model:** A CNN-LSTM for detecting attack patterns in network data.
                            -   **Threats We Detect:** Backdoor, DDoS, MITM, Port Scanning, Ransomware.
                        3.  **Decline Other Topics:** If asked about anything else (e.g., "what is the weather?"), you MUST politely decline by saying: "My expertise is focused on the FedIds platform and IIoT security. I cannot answer questions on other topics."
                        """
                    ]
                },
                {
                    "role": "model",
                    "parts": ["Understood. I am FedIds Assist. How can I help you?"]
                }
            ]
        )
        
        response = await chat_session.send_message_async(query.question)
        
        return ChatResponse(answer=response.text)

    except Exception as e:
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Gemini API error: {e}")


@app.get("/api/admin/chatbot/stats", response_model=List[ChatStat], dependencies=[Depends(get_current_admin_user)])
async def get_chatbot_stats(db: Session = Depends(get_db)):
    logs = db.query(ChatLog.question).all()
    if not logs: return []

    questions = [log.question for log in logs]
    
    try:
        # === ON UTILISE LE MODÈLE LE PLUS STABLE ===
        model = genai.GenerativeModel('gemini-pro-latest')
        
        prompt = f"""
        Analyze and categorize the following user questions into one of these topics: "IIoT Concepts", "Specific Attacks", "Greetings", or "Other".
        Return the answer ONLY as a JSON list of strings. Example: ["Specific Attacks", "Greetings", "IIoT Concepts"].
        
        Questions: {json.dumps(questions)}
        """
        
        response = await model.generate_content_async(prompt)
        cleaned_response = response.text.strip().replace("```json", "").replace("```", "")
        categories = json.loads(cleaned_response)
        
        category_counts = {}
        for category in categories:
            category_counts[category] = category_counts.get(category, 0) + 1
            
        stats = [{"question": category, "count": count} for category, count in category_counts.items()]
        return sorted(stats, key=lambda x: x['count'], reverse=True)

    except Exception as e:
        print(f"Error during stats categorization: {e}")
        # Fallback to raw stats
        stats = db.query(ChatLog.question, func.count(ChatLog.question).label('count')).group_by(ChatLog.question).order_by(func.count(ChatLog.question).desc()).limit(10).all()
        return stats
    

@app.post("/api/devices/log-prevention", status_code=201)
def log_prevention_action(log_data: PreventionLogCreate, db: Session = Depends(get_db)):
    # On vérifie que l'api_key est valide
    device = db.query(Device).filter_by(api_key=log_data.api_key).first()
    if not device:
        raise HTTPException(status_code=404, detail="Device not found.")
    
    new_log = PreventionLog(**log_data.model_dump())
    db.add(new_log)
    db.commit()
    return {"status": "log recorded"}



@app.get("/api/devices/{device_id}/prevention-logs", response_model=List[PreventionLogPublic])
def get_prevention_logs(device_id: int, current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    # On vérifie que l'utilisateur est bien le propriétaire de l'appareil
    device = db.query(Device).filter(Device.id == device_id, Device.owner_id == current_user.id).first()
    if not device:
        raise HTTPException(status_code=404, detail="Device not found.")
        
    return db.query(PreventionLog).filter(PreventionLog.api_key == device.api_key).order_by(PreventionLog.timestamp.desc()).limit(5).all()# ------------------------------------------------------------
# WebSockets routes
# ------------------------------------------------------------
@app.websocket("/ws/attacks")
async def websocket_attacks(websocket: WebSocket, db: Session = Depends(get_db)):
    token = websocket.query_params.get("token")
    if not token:
        await websocket.close(code=http_status.WS_1008_POLICY_VIOLATION)
        return
    user = await get_current_user(token, db)
    await manager.connect(websocket, "attacks")
    try:
        while True:
            await websocket.receive_text()
    except WebSocketDisconnect:
        manager.disconnect(websocket, "attacks")

# ------------------------------------------------------------
# SECTION 10: Uvicorn launcher
# ------------------------------------------------------------
if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=int(os.getenv('PORT', 8000)), reload=True)
