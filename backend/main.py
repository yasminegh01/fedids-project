# backend/main.py (CLEANED) - generated by ChatGPT

import random
import os
import uuid
import json
import shutil
import secrets
import asyncio
import base64
import io
import time
from datetime import datetime, timedelta
from contextlib import asynccontextmanager
from typing import List, Optional, Dict
from urllib.parse import urlencode
from fastapi import status as http_status

from dotenv import load_dotenv
import uvicorn
from fastapi import (
    Depends,
    FastAPI,
    HTTPException,
    BackgroundTasks,
    Request,
    WebSocket,
    
    File,
    UploadFile,
    Response,
)
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import OAuth2PasswordRequestForm, OAuth2PasswordBearer
from fastapi.staticfiles import StaticFiles
from fastapi.responses import JSONResponse, PlainTextResponse, RedirectResponse
from passlib.context import CryptContext
from jose import JWTError, jwt
from pydantic import BaseModel, EmailStr, ConfigDict


from sqlalchemy import (
    create_engine,
    Column,
    Integer,
    String,
    Float,
    DateTime,
    ForeignKey,
    Text,
    Boolean,
    func, 
    UniqueConstraint 
)
from datetime import datetime, UTC
from sqlalchemy.orm import declarative_base,sessionmaker, Session, relationship, selectinload
#from sqlalchemy.ext.declarative import declarative_base

from starlette.middleware.sessions import SessionMiddleware
from starlette.websockets import WebSocketDisconnect

from authlib.integrations.starlette_client import OAuth
from fastapi_mail import ConnectionConfig, FastMail, MessageSchema
from geoip2.database import Reader
import httpx
import stripe
import requests
import configparser

# ML / plotting
import numpy as np
import pandas as pd
from sklearn.preprocessing import MinMaxScaler, LabelEncoder
from sklearn.metrics import classification_report, confusion_matrix
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt
import seaborn as sns
import io
import base64
from model_definition import create_model
# Optional libs
try:
    import flwr as fl
except Exception:
    fl = None

# Local model factory
from model_definition import create_model
import subprocess
import sys
from typing import List, Optional, Dict, Tuple # <<< Assurez-vous que Tuple est importé
from sqlalchemy.orm import joinedload
import google.generativeai as genai

# ------------------------------------------------------------
# SECTION 2: Global configuration
# ------------------------------------------------------------
print("--- MAIN.PY LOADED - VERSION DU 7 SEPTEMBRE ---")
load_dotenv()
DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///./fedids_main.db")
SECRET_KEY = os.getenv("SECRET_KEY", "super-secret-dev-key")
ALGORITHM = "HS256"
GEOIP_DB_PATH = os.getenv("GEOIP_DB_PATH", "geoip_db/GeoLite2-City.mmdb")
PREMIUM_PLAN_PRICE = int(os.getenv("PREMIUM_PLAN_PRICE", "200"))
FRONTEND_BASE = os.getenv("FRONTEND_BASE", "http://localhost:5173")
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
if GEMINI_API_KEY:
    genai.configure(api_key=GEMINI_API_KEY)
mail_conf = ConnectionConfig(
    MAIL_USERNAME=os.getenv("MAIL_USERNAME"),
    MAIL_PASSWORD=os.getenv("MAIL_PASSWORD"),
    MAIL_FROM=os.getenv("MAIL_FROM"),
    MAIL_PORT=int(os.getenv("MAIL_PORT", 587)),
    MAIL_SERVER=os.getenv("MAIL_SERVER"),
    MAIL_STARTTLS=True,
    MAIL_SSL_TLS=False,
)
stripe.api_key = os.getenv("STRIPE_SECRET_KEY")

try:
    geoip_reader = Reader(GEOIP_DB_PATH)
except Exception:
    geoip_reader = None




FLOWER_PROCESS = None

# ------------------------------------------------------------
# SECTION 3: Database setup
# ------------------------------------------------------------
DATABASE_URL = os.getenv("DATABASE_URL")
Base = declarative_base()
#engine = create_engine(DATABASE_URL, connect_args={"check_same_thread": False})
engine = create_engine(DATABASE_URL)

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# ------------------------------------------------------------
# SECTION 4: SQLAlchemy models
# ------------------------------------------------------------

class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True)
    email = Column(String, unique=True, nullable=False)
    username = Column(String, unique=True)
    hashed_password = Column(String, nullable=True)
    
    # --- NOUVEAUX CHAMPS ---
    full_name = Column(String, nullable=True)
    company = Column(String, nullable=True)
    job_title = Column(String, nullable=True) # Ex: "Ingénieur Sécurité", "Manager"
    country = Column(String, nullable=True)
    
    role = Column(String, default="user") # user, premium, admin
    is_active = Column(Boolean, default=False)
    verification_code = Column(String, nullable=True)
    password_reset_token = Column(String, nullable=True) # Pour le mot de passe oublié
    password_reset_expires = Column(DateTime, nullable=True)
    
    google_id = Column(String, unique=True, nullable=True)
    profile_picture_url = Column(String, nullable=True)
    subscription_valid_until = Column(DateTime, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    
    devices = relationship("Device", back_populates="owner", cascade="all, delete-orphan")
    tickets = relationship("Ticket", foreign_keys="[Ticket.user_id]", back_populates="user")




class Device(Base):
    __tablename__ = "devices"
    id = Column(Integer, primary_key=True)
    
    # --- NOUVEAUX CHAMPS ---
    category = Column(String, nullable=False, default="default")
    name = Column(String, nullable=False) # Ex: "Imprimante"
    # On ajoute une contrainte d'unicité pour le couple (owner_id, category, name)
    __table_args__ = (UniqueConstraint('owner_id', 'category', 'name', name='_owner_category_name_uc'),)

    api_key = Column(String, unique=True, default=lambda: uuid.uuid4().hex)
    owner_id = Column(Integer, ForeignKey("users.id"))
    owner = relationship("User", back_populates="devices")
    prevention_enabled = Column(Boolean, default=False)
    registration_token = Column(String, unique=True, nullable=True)



class DeviceStatus(Base):
    __tablename__ = "device_status"
    id = Column(Integer, primary_key=True)
    device_api_key = Column(String, ForeignKey("devices.api_key"), unique=True)
    last_seen = Column(DateTime, default=datetime.utcnow)
    status = Column(String, default="offline")


class AttackLog(Base):
    __tablename__="attack_logs";id=Column(Integer,primary_key=True);timestamp=Column(DateTime,default=datetime.utcnow);source_ip=Column(String);attack_type=Column(String);confidence=Column(Float);latitude=Column(Float,nullable=True);longitude=Column(Float,nullable=True);city=Column(String,nullable=True);country=Column(String,nullable=True)

class Client(Base):
    __tablename__ = "clients"
    id = Column(Integer, primary_key=True)
    flower_id = Column(String, unique=True)
    name = Column(String)
    status = Column(String, default="active")
    notes = Column(Text, nullable=True)
    registered_at = Column(DateTime, default=datetime.utcnow)
    history_records = relationship("ClientHistory", back_populates="client", cascade="all, delete-orphan")


class ClientHistory(Base):
    __tablename__="client_history";id=Column(Integer,primary_key=True);client_id=Column(Integer,ForeignKey("clients.id"));server_round=Column(Integer);accuracy=Column(Float);loss=Column(Float);timestamp=Column(DateTime,default=datetime.utcnow);client=relationship("Client",back_populates="history_records")

class Payment(Base):
    __tablename__="payments";id=Column(Integer,primary_key=True);user_id=Column(Integer,ForeignKey("users.id"));stripe_payment_intent_id=Column(String,unique=True);amount=Column(Integer);currency=Column(String);status=Column(String);created_at=Column(DateTime,default=datetime.utcnow);user=relationship("User")

class AnalysisHistory(Base):
    __tablename__ = "analysis_history"
    id = Column(Integer, primary_key=True)
    filename = Column(String)
    timestamp = Column(DateTime, default=datetime.utcnow)
    # On stocke les rapports sous forme de texte JSON
    classification_report = Column(Text) 
    confusion_matrix_b64 = Column(Text) # Assez long pour une chaîne base64
    
    # On lie l'analyse à l'admin qui l'a lancée
    admin_id = Column(Integer, ForeignKey("users.id"))

    
class Ticket(Base):
    __tablename__ = "tickets"
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    subject = Column(String, nullable=False)
    assigned_admin_id = Column(Integer, ForeignKey("users.id"), nullable=True)
    
    # --- NOUVEAUX CHAMPS ---
    category = Column(String, default="general")
    status = Column(String, default="open")
    priority = Column(String, default="medium")
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # === LA CORRECTION EST ICI ===
    
    # Relation pour le créateur du ticket
    user = relationship("User", foreign_keys=[user_id], back_populates="tickets")
    
    # Relation pour l'admin assigné
    assigned_admin = relationship("User", foreign_keys=[assigned_admin_id])
    
    messages = relationship("TicketMessage", back_populates="ticket", cascade="all, delete-orphan")


class FaqArticle(Base):
    __tablename__ = "faq_articles"
    id = Column(Integer, primary_key=True)
    question = Column(String, nullable=False)
    answer = Column(Text, nullable=False)
    keywords = Column(String) # Mots-clés séparés par des virgules
    category = Column(String, default="general") # general, technical, billing

class TicketMessage(Base):
    __tablename__ = "ticket_messages"
    id = Column(Integer, primary_key=True)
    ticket_id = Column(Integer, ForeignKey("tickets.id"))
    author_id = Column(Integer, ForeignKey("users.id")) # L'ID de l'utilisateur ou de l'admin
    message = Column(Text, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    
    ticket = relationship("Ticket", back_populates="messages")
    author = relationship("User", foreign_keys=[author_id])

class ChatLog(Base):
    __tablename__ = "chat_logs"
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    question = Column(Text, nullable=False)
    # On pourrait aussi stocker la réponse du modèle si on le voulait
    # answer = Column(Text) 
    timestamp = Column(DateTime, default=datetime.utcnow)
    
    user = relationship("User")
def get_db():db=SessionLocal();yield db;db.close()
# ------------------------------------------------------------
# SECTION 5: Pydantic models (schemas)
# ------------------------------------------------------------
# --- Pydantic Models ---
class UserCreate(BaseModel):
    email:EmailStr
    username:str
    password:str
    full_name: str
    company: Optional[str] = None
    country: Optional[str] = None
class PasswordResetRequest(BaseModel):
    email: EmailStr

class PasswordResetConfirm(BaseModel):
    token: str
    new_password: str

class UserProfileUpdate(BaseModel):
    username: Optional[str] = None
    full_name: Optional[str] = None
    company: Optional[str] = None
    
    # === AJOUTEZ CES DEUX LIGNES ===
    country: Optional[str] = None
    job_title: Optional[str] = None
    
    
class UserPublic(BaseModel):
    id: int
    email: str
    username: Optional[str] = None
    role: str
    profile_picture_url: Optional[str] = None
    subscription_valid_until: Optional[datetime] = None
    full_name: Optional[str] = None
    company: Optional[str] = None
    
    # === AJOUTEZ CES DEUX LIGNES ===
    country: Optional[str] = None
    job_title: Optional[str] = None
    
    # --- ASSUREZ-VOUS QUE CES CHAMPS SONT AUSSI LÀ ---
    is_active: bool
    created_at: datetime

    class Config:
        from_attributes = True
class UserAdminView(UserPublic):device_count:int;devices_with_prevention_on:int;payment_count:int
class Token(BaseModel):access_token:str;token_type:str;user:UserPublic
class DeviceCreate(BaseModel):name:str
class DevicePublic(BaseModel):
    id:int;name:str;api_key:str;prevention_enabled:bool;registration_token:Optional[str]=None
    model_config=ConfigDict(from_attributes=True)

class DeviceStatusPublic(BaseModel):
    last_seen: Optional[datetime]
    status: str

    class Config:
        from_attributes = True

class DeviceAdminView(DevicePublic):
    owner_email: str
    status: Optional[str] = 'unknown'

class DeviceWithStatus(DevicePublic):
    status_info: Optional[DeviceStatusPublic] = None



class HeartbeatPayload(BaseModel):
    api_key: str


class DashboardStats(BaseModel):
    device_count: int
    attacks_this_week: int
    last_attack_timestamp: Optional[datetime] = None


class FLClientRegistration(BaseModel):
    api_key: str
    flower_cid: str

class AnalysisHistoryPublic(BaseModel):
    id: int
    filename: str
    timestamp: datetime
    class Config: from_attributes = True

class VerificationData(BaseModel):email:EmailStr;code:str
class AttackReport(BaseModel):source_ip:str;attack_type:str;confidence:float
class AttackLogPublic(BaseModel):id:int;timestamp:datetime;source_ip:str;attack_type:str;confidence:float;city:Optional[str]=None;country:Optional[str]=None;model_config=ConfigDict(from_attributes=True)
class ClientModel(BaseModel):
    id:int
    flower_id:str
    name:str
    status:str
    notes:Optional[str]
    registered_at:datetime
    owner_username: Optional[str] = None
    owner_email: Optional[str] = None
    model_config=ConfigDict(from_attributes=True)

class AdminStats(BaseModel):total_users:int;premium_users:int;total_devices:int;online_devices:int;total_attacks_24h:int

class FLRoundHistory(BaseModel):
    server_round: int
    accuracy: float
    loss: float
    timestamp: datetime
    class Config: from_attributes = True

class EvaluationResult(BaseModel):
    report: dict
    confusion_matrix_b64: str

class HistoryModel(BaseModel):
    server_round: int
    accuracy: float
    loss: float
    timestamp: datetime

    class Config:
        from_attributes = True

class FLStatus(BaseModel): server_round: int; accuracy: float
class ClientHistoryPayload(BaseModel):
    client_flower_id: str; server_round: int; accuracy: float; loss: float

class ClientHistoryAdminView(BaseModel):
    server_round: int
    accuracy: float
    loss: float
    timestamp: datetime
    class Config: from_attributes = True

class ClientAdminView(BaseModel):
    id: int
    flower_id: str
    name: str
    status: str
    registered_at: datetime
    # On ajoute des informations sur le propriétaire
    owner_username: Optional[str] = None
    owner_email: Optional[str] = None
    class Config: from_attributes = True

class GlobalRoundHistory(BaseModel):
    server_round: int
    accuracy: Optional[float] = None
    loss: Optional[float] = None
    timestamp: datetime

    class Config:
        from_attributes = True


class TrainingStatus(BaseModel):
    is_running: bool
    pid: Optional[int] = None # Process ID
class TicketCreate(BaseModel):
   category: str
   subject: str
   message: str

class TicketMessageCreate(BaseModel):
    message: str

class TicketResponsePublic(BaseModel):
    id: int
    author_id: int
    message: str
    created_at: datetime
    class Config: from_attributes = True

class TicketPublic(BaseModel):
    id: int
    user_id: int
    subject: str
    status: str
    priority: str
    created_at: datetime
    updated_at: datetime
    responses: List[TicketResponsePublic] = []
    class Config: from_attributes = True


class ForgotPasswordRequest(BaseModel):
    email: EmailStr

class ResetPasswordRequest(BaseModel):
    token: str
    new_password: str


class ChatQuery(BaseModel):
    question: str
    history: List[Dict[str, str]] # ex: [{"role": "user", "text": "..."}, {"role": "model", "text": "..."}]

class ChatResponse(BaseModel):
    answer: str


class ChatStat(BaseModel):
    question: str
    count: int
# ------------------------------------------------------------
# SECTION 6: Helpers (auth, utils)
# ------------------------------------------------------------
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/auth/login")
oauth = OAuth()


def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)


def verify_password(password: str, hashed: str) -> bool:
    return pwd_context.verify(password, hashed)


def create_access_token(data: dict):
    expire = datetime.utcnow() + timedelta(days=1)
    payload = {**data, "exp": expire}
    return jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)


def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


async def get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)):
    exc = HTTPException(status_code=401, detail="Invalid token")
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username = payload.get("sub")
        if not username:
            raise exc
    except JWTError:
        raise exc
    user = db.query(User).filter(User.username == username).first()
    if not user:
        raise exc
    return user


async def get_current_admin_user(user: User = Depends(get_current_user)):
    if user.role != "admin":
        raise HTTPException(status_code=403, detail="Not authorized")
    return user


def enrich_geoip(ip: str):
    if not geoip_reader:
        return None, None, None, None
    try:
        response = geoip_reader.city(ip)
        lat = response.location.latitude
        lon = response.location.longitude
        city = response.city.name
        country = response.country.name
        return lat, lon, city, country
    except Exception:
        return None, None, None, None


async def send_ntfy_notification(attack: AttackLog):
    try:
        message = f"🚨 {attack.attack_type} from {attack.source_ip} ({attack.country or 'Unknown'})"
        async with httpx.AsyncClient() as client:
            await client.post(
                os.getenv("NTFY_TOPIC_URL", "https://ntfy.sh/ok"),
                data=message.encode("utf-8"),
                headers={"Title": "FedIDS Alert", "Priority": "high"},
            )
    except Exception as e:
        print("❌ Ntfy error:", e)


def log_to_json_serializable(log_entry: AttackLog) -> Dict:
    return {
        "id": log_entry.id,
        "timestamp": log_entry.timestamp.isoformat(),
        "source_ip": log_entry.source_ip,
        "attack_type": log_entry.attack_type,
        "confidence": log_entry.confidence,
        "latitude": log_entry.latitude,
        "longitude": log_entry.longitude,
        "city": log_entry.city,
        "country": log_entry.country,
    }


# ------------------------------------------------------------
# SECTION 7: Lifespan & app instance
# ------------------------------------------------------------
@asynccontextmanager
async def lifespan(app: FastAPI):
    oauth.register(
        name="google",
        client_id=os.getenv("GOOGLE_CLIENT_ID"),
        client_secret=os.getenv("GOOGLE_CLIENT_SECRET"),
        server_metadata_url="https://accounts.google.com/.well-known/openid-configuration",
        client_kwargs={"scope": "openid email profile"},
    )
    Base.metadata.create_all(bind=engine)
    # create default admin if none
    with SessionLocal() as db:
        if not db.query(User).filter_by(username="yasmine").first():
            admin = User(
                email="yasmine@fedids.io",
                username="yasmine",
                hashed_password=get_password_hash("yasmine"),
                role="admin",
                is_active=True,
            )
            db.add(admin)
            db.commit()
    yield


app = FastAPI(title="FedIds API", lifespan=lifespan)

# ------------------------------------------------------------
# SECTION 8: Middlewares & static files
# ------------------------------------------------------------
os.makedirs("static/profile_pics", exist_ok=True)
app.mount("/static", StaticFiles(directory="static"), name="static")
app.add_middleware(SessionMiddleware, secret_key=SECRET_KEY)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


# WebSocket manager
class ConnectionManager:
    def __init__(self):
        self.channels: Dict[str, List[WebSocket]] = {"attacks": [], "fl_status": []}

    async def connect(self, ws: WebSocket, channel: str):
        await ws.accept()
        self.channels.setdefault(channel, []).append(ws)

    def disconnect(self, ws: WebSocket, channel: str):
        if ws in self.channels.get(channel, []):
            self.channels[channel].remove(ws)

    async def broadcast(self, msg: str, ch: str):
        await asyncio.gather(*(c.send_text(msg) for c in self.channels.get(ch, [])), return_exceptions=True)


manager = ConnectionManager()


# ------------------------------------------------------------
# SECTION 9: Routes
# (kept your logic; fixed small errors and duplicates)
# ------------------------------------------------------------



@app.post("/api/auth/verify")
def verify_email(data: VerificationData, db: Session = Depends(get_db)):
    user = db.query(User).filter_by(email=data.email).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    if user.is_active:
        return {"message": "Already activated"}
    if user.verification_code != data.code:
        raise HTTPException(status_code=400, detail="Invalid code")
    user.is_active = True
    user.verification_code = None
    db.commit()
    return {"message": "Account activated"}


@app.post("/api/auth/login", response_model=Token)
def login(db: Session = Depends(get_db), f: OAuth2PasswordRequestForm = Depends()):
    user = db.query(User).filter(User.username == f.username).first()
    if not user or not user.hashed_password or not verify_password(f.password, user.hashed_password):
        raise HTTPException(status_code=401, detail="Invalid credentials")
    token = create_access_token({"sub": user.username})
    return Token(access_token=token, token_type="bearer", user=UserPublic.model_validate(user))

@app.post("/api/auth/request-password-reset")
async def request_password_reset(request: PasswordResetRequest, background_tasks: BackgroundTasks, db: Session = Depends(get_db)):
    user = db.query(User).filter(User.email == request.email).first()
    if not user:
        # On ne révèle pas si l'email existe ou non pour des raisons de sécurité
        return {"message": "If an account with this email exists, a password reset link has been sent."}

    # Générer un token sécurisé et une date d'expiration (ex: 1 heure)
    token = secrets.token_urlsafe(32)
    expires = datetime.utcnow() + timedelta(hours=1)
    
    user.password_reset_token = token
    user.password_reset_expires = expires
    db.commit()

    # Envoyer l'email avec le lien de réinitialisation
    reset_link = f"http://localhost:5173/reset-password?token={token}"
    fm = FastMail(mail_conf)
    msg = MessageSchema(
        subject="FedIds - Password Reset Request",
        recipients=[user.email],
        body=f"<p>Please click the following link to reset your password: <a href='{reset_link}'>{reset_link}</a></p>",
        subtype="html"
    )
    background_tasks.add_task(fm.send_message, msg)
    
    return {"message": "Password reset link sent."}

@app.post("/api/auth/confirm-password-reset")
def confirm_password_reset(request: PasswordResetConfirm, db: Session = Depends(get_db)):
    user = db.query(User).filter(
        User.password_reset_token == request.token,
        User.password_reset_expires > datetime.utcnow()
    ).first()

    if not user:
        raise HTTPException(status_code=400, detail="Invalid or expired password reset token.")

    # Mettre à jour le mot de passe et invalider le token
    user.hashed_password = get_password_hash(request.new_password)
    user.password_reset_token = None
    user.password_reset_expires = None
    db.commit()

    return {"message": "Password has been reset successfully."}
@app.get("/api/users/me", response_model=UserPublic)
async def read_users_me(current_user: User = Depends(get_current_user)):
    return current_user


@app.put("/api/users/me/profile", response_model=UserPublic)
def update_user_profile(
    profile_data: UserProfileUpdate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    update_data = profile_data.model_dump(exclude_unset=True)
    for key, value in update_data.items():
        setattr(current_user, key, value)
    db.commit()
    db.refresh(current_user)
    return current_user


@app.post("/api/users/me/upload-picture", response_model=UserPublic)
async def upload_profile_picture(
    file: UploadFile = File(...), user: User = Depends(get_current_user), db: Session = Depends(get_db)
):
    file_ext = os.path.splitext(file.filename)[1]
    filename = f"{user.id}_{uuid.uuid4().hex}{file_ext}"
    file_path = os.path.join("static", "profile_pics", filename)
    with open(file_path, "wb") as buffer:
        shutil.copyfileobj(file.file, buffer)
    user.profile_picture_url = f"/static/profile_pics/{filename}"
    db.commit()
    db.refresh(user)
    return user


@app.get("/profile-pic/{filename}")
async def get_profile_pic(filename: str):
    file_path = os.path.join("static", "profile_pics", filename)
    if not os.path.exists(file_path):
        raise HTTPException(status_code=404, detail="Profile picture not found")
    return {"url": f"/static/profile_pics/{filename}"}


@app.post("/api/users/me/upgrade-to-premium", response_model=UserPublic)
def upgrade_user_to_premium(current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    user = current_user
    
    if user.role != "premium":
        user.role = "premium"
    
    user.subscription_valid_until = datetime.utcnow() + timedelta(days=90)
    
    # === LA CORRECTION EST ICI ===
    # On simule la création d'un enregistrement de paiement
    new_payment = Payment(
        user_id=user.id,
        stripe_payment_intent_id=f"sim_{uuid.uuid4().hex}", # ID simulé
        amount=200, # Montant en centimes
        currency="eur",
        status="succeeded"
    )
    db.add(new_payment)
    # === FIN DE LA CORRECTION ===
    
    db.commit()
    db.refresh(user)
    
    return UserPublic.model_validate(user)


# Devices
@app.post("/api/devices/register", response_model=DevicePublic)
def register_device(device_in: DeviceCreate, user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    new_device = Device(name=device_in.name, owner_id=user.id, registration_token=secrets.token_hex(16))
    db.add(new_device)
    db.commit()
    db.refresh(new_device)
    return new_device


@app.get("/api/devices/install/{reg_token}", response_class=PlainTextResponse)
def get_install_script(reg_token: str, db: Session = Depends(get_db)):
    device = db.query(Device).filter(Device.registration_token == reg_token).first()
    if not device:
        return "echo '❌ Error: Invalid or expired registration token.'; exit 1"

    api_key = device.api_key
    device.registration_token = None
    db.commit()

    github_client_repo_url = "https://github.com/yasminegh01/fedids-iiot-client.git"

    script_content = f"""#!/bin/bash
set -e

# 1. System deps
sudo apt-get update
sudo apt-get install -y git python3.11 python3.11-venv libasound2-dev

# 2. Clone
git clone {github_client_repo_url} iiot_client || (cd iiot_client && git pull)
cd iiot_client

# 3. venv & deps
python3.11 -m venv venv
source venv/bin/activate
pip install -r requirements.txt

# 4. config
cat > config.ini <<EOF
[device]
api_key = {api_key}
EOF

echo "Installation complete"
"""
    return script_content


@app.get("/api/devices/my-devices-with-status", response_model=List[DeviceWithStatus])
def get_my_devices_with_status(user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    five_min = datetime.utcnow() - timedelta(minutes=5)
    db.query(DeviceStatus).filter(DeviceStatus.last_seen < five_min).update({"status": "offline"}, synchronize_session=False)
    db.commit()
    response = []
    for d in user.devices:
        status_obj = db.query(DeviceStatus).filter_by(device_api_key=d.api_key).first()
        response.append(
            DeviceWithStatus(**DevicePublic.model_validate(d).model_dump(), status_info=DeviceStatusPublic.model_validate(status_obj) if status_obj else None)
        )
    return response


@app.post("/api/devices/heartbeat")
def device_heartbeat(payload: HeartbeatPayload, db: Session = Depends(get_db)):
    d = db.query(Device).filter_by(api_key=payload.api_key).first()
    if not d:
        raise HTTPException(status_code=404, detail="Device not found")
    status_obj = db.query(DeviceStatus).filter_by(device_api_key=d.api_key).first()
    if status_obj:
        status_obj.last_seen = datetime.utcnow()
        status_obj.status = "online"
    else:
        db.add(DeviceStatus(device_api_key=d.api_key, status="online", last_seen=datetime.utcnow()))
    db.commit()
    return {"status": "ok"}


@app.get("/api/devices/{api_key}/settings")
def get_device_settings(api_key: str, db: Session = Depends(get_db)):
    device = db.query(Device).filter(Device.api_key == api_key).first()
    if not device:
        raise HTTPException(status_code=404, detail="Device not found")
    return {"prevention_enabled": device.prevention_enabled}


@app.post("/api/devices/{device_id}/toggle-prevention", response_model=DevicePublic)
def toggle_prevention(device_id: int, user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    if user.role != "premium":
        raise HTTPException(status_code=403, detail="This is a premium feature.")
    device = db.query(Device).filter(Device.id == device_id, Device.owner_id == user.id).first()
    if not device:
        raise HTTPException(status_code=404, detail="Device not found or not owned by user.")
    device.prevention_enabled = not device.prevention_enabled
    db.commit()
    db.refresh(device)
    return device


@app.delete("/api/devices/{device_id}", status_code=http_status.HTTP_204_NO_CONTENT)
def delete_device(
    device_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    device_to_delete = db.query(Device).filter(
        Device.id == device_id,
        Device.owner_id == current_user.id,
    ).first()

    if not device_to_delete:
        raise HTTPException(status_code=404, detail="Device not found.")

    db.delete(device_to_delete)
    db.commit()
    return Response(status_code=http_status.HTTP_204_NO_CONTENT)


# Dashboard / attacks
@app.get("/api/dashboard/stats", response_model=DashboardStats)
def get_user_dashboard_stats(current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    seven_days_ago = datetime.utcnow() - timedelta(days=7)
    attacks = db.query(AttackLog).filter(AttackLog.timestamp >= seven_days_ago).count()
    last = db.query(AttackLog).order_by(AttackLog.timestamp.desc()).first()
    return DashboardStats(device_count=len(current_user.devices), attacks_this_week=attacks, last_attack_timestamp=last.timestamp if last else None)


@app.get("/api/attacks/history", response_model=List[AttackLogPublic])
def get_attack_history(current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    return db.query(AttackLog).order_by(AttackLog.timestamp.desc()).limit(50).all()


@app.post("/api/attacks/report", response_model=AttackLogPublic)
async def report_attack(report: AttackReport, db: Session = Depends(get_db)):
    lat, lon, city, country = enrich_geoip(report.source_ip)
    new_log = AttackLog(
        source_ip=report.source_ip,
        attack_type=report.attack_type,
        confidence=report.confidence,
        latitude=lat,
        longitude=lon,
        city=city,
        country=country,
    )
    db.add(new_log)
    db.commit()
    db.refresh(new_log)
    await manager.broadcast(json.dumps(log_to_json_serializable(new_log)), "attacks")
    await send_ntfy_notification(new_log)
    return new_log


@app.post("/api/fl_update")
async def fl_update(status: FLStatus):
    print(f"Received FL update: Round {status.server_round}, Accuracy {status.accuracy:.4f}")
    await manager.broadcast(status.model_dump_json(), "fl_status")
    return {"status": "broadcasted"}


# Admin
@app.get("/api/admin/dashboard", response_model=DashboardStats)
def get_dashboard(current_user: User = Depends(get_current_admin_user), db: Session = Depends(get_db)):
    count = db.query(Device).count()
    attacks = db.query(AttackLog).filter(AttackLog.timestamp > datetime.utcnow() - timedelta(days=7)).count()
    last = db.query(AttackLog).order_by(AttackLog.timestamp.desc()).first()
    return DashboardStats(device_count=count, attacks_this_week=attacks, last_attack_timestamp=last.timestamp if last else None)


@app.get("/api/admin/clients", response_model=List[ClientAdminView], dependencies=[Depends(get_current_admin_user)])
def get_admin_clients(db: Session = Depends(get_db)):
    clients = db.query(Client).all()
    response = []
    for client in clients:
        user = db.query(User).filter(User.google_id == client.flower_id).first()
        
        # On utilise maintenant le bon modèle de réponse
        client_data = ClientAdminView(
            id=client.id,
            flower_id=client.flower_id,
            name=client.name,
            status=client.status,
            notes=client.notes,
            registered_at=client.registered_at,
            owner_username=user.username if user else "N/A",
            owner_email=user.email if user else "N/A"
        )
        response.append(client_data)
        
    return response

@app.get("/api/admin/clients/{client_id}/history", response_model=List[HistoryModel], dependencies=[Depends(get_current_admin_user)])
def get_client_history(client_id: int, db: Session = Depends(get_db)):
    history = db.query(ClientHistory).filter(ClientHistory.client_id == client_id).order_by(ClientHistory.server_round.asc()).all()
    return history



@app.get("/api/admin/attacks/history", response_model=List[AttackLogPublic], dependencies=[Depends(get_current_admin_user)])
def get_global_attack_history(db: Session = Depends(get_db)):
    return db.query(AttackLog).order_by(AttackLog.timestamp.desc()).limit(200).all()


@app.post("/api/admin/client_history")
def save_client_history(
    history_payload: List[ClientHistoryPayload],
    db: Session = Depends(get_db),
):
    for record in history_payload:
        client = db.query(Client).filter(Client.flower_id == record.client_flower_id).first()
        if not client:
            client = Client(flower_id=record.client_flower_id, name=f"Client_{record.client_flower_id[:6]}")
            db.add(client)
            db.commit()
            db.refresh(client)
        history_entry = ClientHistory(
            client_id=client.id,
            server_round=record.server_round,
            accuracy=record.accuracy,
            loss=record.loss,
        )
        db.add(history_entry)
    db.commit()
    return {"status": "history saved"}


@app.get("/api/admin/stats", response_model=AdminStats, dependencies=[Depends(get_current_admin_user)])
def get_admin_stats(db: Session = Depends(get_db)):
    twenty_four_hours_ago = datetime.utcnow() - timedelta(hours=24)
    stats = AdminStats(
        total_users=db.query(User).count(),
        premium_users=db.query(User).filter(User.role == "premium").count(),
        total_devices=db.query(Device).count(),
        online_devices=db.query(DeviceStatus).filter(DeviceStatus.status == "online").count(),
        total_attacks_24h=db.query(AttackLog).filter(AttackLog.timestamp >= twenty_four_hours_ago).count(),
    )
    return stats


@app.get("/api/admin/users", response_model=List[UserAdminView], dependencies=[Depends(get_current_admin_user)])
def get_all_users_for_admin(db: Session = Depends(get_db)):
    users = db.query(User).options(selectinload(User.devices)).all()
    response = []
    for user in users:
        prevention_on_count = sum(1 for device in user.devices if device.prevention_enabled)
        payment_count = db.query(Payment).filter(Payment.user_id == user.id, Payment.status == "succeeded").count()
        user_dict = UserPublic.model_validate(user).model_dump()
        user_dict["device_count"] = len(user.devices)
        user_dict["devices_with_prevention_on"] = prevention_on_count
        user_dict["payment_count"] = payment_count
        user_data = UserAdminView.model_validate(user_dict)
        response.append(user_data)
    return response
@app.put("/api/admin/users/{user_id}/status", response_model=UserPublic, dependencies=[Depends(get_current_admin_user)])
def toggle_user_status(user_id: int, db: Session = Depends(get_db)):
    """
    Inverse le statut 'is_active' d'un utilisateur (suspendre/réactiver).
    Protégé pour les administrateurs uniquement.
    """
    user = db.query(User).filter(User.id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    
    # On ne peut pas désactiver le super-admin
    if user.role == "admin":
        raise HTTPException(status_code=403, detail="Cannot change the status of an admin account.")
        
    # Inverser la valeur actuelle
    user.is_active = not user.is_active
    db.commit()
    db.refresh(user)
    
    print(f"Admin action: User '{user.username}' status set to {user.is_active}")
    return user


@app.get("/api/admin/fl-global-history", response_model=List[GlobalRoundHistory], dependencies=[Depends(get_current_admin_user)])
def get_fl_global_history(db: Session = Depends(get_db)):
    """
    Récupère et agrège l'historique de performance global, round par round.
    """
    # C'est une requête SQL complexe traduite en SQLAlchemy :
    # On groupe les entrées de ClientHistory par numéro de round.
    # Pour chaque round, on calcule la moyenne de l'accuracy et de la loss.
    # On prend aussi le timestamp le plus récent pour ce round.
    history = (
        db.query(
            ClientHistory.server_round,
            func.avg(ClientHistory.accuracy).label("accuracy"),
            func.avg(ClientHistory.loss).label("loss"),
            func.max(ClientHistory.timestamp).label("timestamp"),
        )
        .group_by(ClientHistory.server_round)
        .order_by(ClientHistory.server_round.asc())
        .all()
    )
    
    # La requête renvoie des tuples, on les convertit en objets Pydantic
    return [GlobalRoundHistory(server_round=r[0], accuracy=r[1], loss=r[2], timestamp=r[3]) for r in history]


@app.get("/api/admin/fl-history", response_model=List[FLRoundHistory], dependencies=[Depends(get_current_admin_user)])
def get_fl_history(db: Session = Depends(get_db)):
    """Récupère l'historique global des rounds d'entraînement."""
    # Note: Pour une vraie agrégation, il faudrait une requête plus complexe.
    # Pour la simulation, on prend l'historique du premier client trouvé.
    history = db.query(ClientHistory).order_by(ClientHistory.server_round.asc()).limit(100).all()
    return history
# Dans backend/main.py

@app.get("/api/admin/analysis-history", response_model=List[AnalysisHistoryPublic], dependencies=[Depends(get_current_admin_user)])
def get_analysis_history(db: Session = Depends(get_db)):
    """Récupère la liste des analyses de modèle passées."""
    return db.query(AnalysisHistory).order_by(AnalysisHistory.timestamp.desc()).limit(20).all()

@app.get("/api/admin/analysis-history/{history_id}", response_model=EvaluationResult, dependencies=[Depends(get_current_admin_user)])
def get_analysis_result(history_id: int, db: Session = Depends(get_db)):
    """Récupère le résultat complet (rapport + matrice) d'une analyse spécifique."""
    analysis = db.query(AnalysisHistory).filter(AnalysisHistory.id == history_id).first()
    if not analysis:
        raise HTTPException(status_code=404, detail="Analysis not found")
    
    return {
        "report": json.loads(analysis.classification_report), # On reconvertit la chaîne JSON en dict
        "confusion_matrix_b64": analysis.confusion_matrix_b64
    }
@app.post("/api/admin/evaluate-model", response_model=EvaluationResult, dependencies=[Depends(get_current_admin_user)])
async def evaluate_model(
    # === LA CORRECTION EST ICI ===
    # On ajoute current_user comme paramètre pour pouvoir l'utiliser
    current_user: User = Depends(get_current_admin_user), 
    file: UploadFile = File(...), 
    db: Session = Depends(get_db)
):
    
    try:
        model = create_model()
        model.load_weights("global_model.weights.h5")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Could not load model: {e}")

    try:
        contents = await file.read()
        df = pd.read_csv(io.BytesIO(contents))
        
        if df.empty:
            raise HTTPException(status_code=400, detail="CSV is empty or improperly formatted.")
    
        feature_columns = df.columns[:-1].tolist()
        label_column = df.columns[-1]
        
        if len(feature_columns) != 7: # NUM_FEATURES
            raise HTTPException(status_code=400, detail=f"Model expects 7 features, but CSV has {len(feature_columns)}.")

        # === LA CORRECTION EST ICI ===
        # 1. Définir la liste complète de toutes les classes que le modèle connaît
        ALL_ATTACK_LABELS = [
            'Backdoor', 'DDoS_HTTP', 'DDoS_ICMP', 'DDoS_TCP', 'DDoS_UDP',
            'Fingerprinting', 'MITM', 'Normal', 'Password', 'Port_Scanning',
            'Ransomware', 'SQL_injection', 'Uploading', 'Vulnerability_scanner', 'XSS'
        ]
        
        # 2. Prétraiter les features
        scaler = MinMaxScaler()
        X_scaled = scaler.fit_transform(df[feature_columns])
        
        # 3. Prétraiter les labels de manière robuste
        encoder = LabelEncoder()
        # On "entraîne" l'encodeur sur TOUTES les classes possibles
        encoder.fit(ALL_ATTACK_LABELS)
        
        # On vérifie que les labels du fichier de test sont connus
        unknown_labels = set(df[label_column]) - set(encoder.classes_)
        if unknown_labels:
            raise HTTPException(status_code=400, detail=f"CSV contains unknown labels: {list(unknown_labels)}")
            
        # On transforme les labels du fichier de test
        y_encoded = encoder.transform(df[label_column])
        
        # 4. Créer les séquences
        X_test, y_test = create_sequences_for_evaluation(X_scaled, y_encoded)
        
    except HTTPException as e:
        raise e # On propage les erreurs HTTP spécifiques
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error processing CSV file: {e}")

    # Prédictions et rapports
    predictions_proba = model.predict(X_test)
    predictions = np.argmax(predictions_proba, axis=1)
    
    # On utilise la liste complète des labels pour le rapport
    report = classification_report(y_test, predictions, labels=range(len(ALL_ATTACK_LABELS)), target_names=ALL_ATTACK_LABELS, output_dict=True)
    cm = confusion_matrix(y_test, predictions, labels=range(len(ALL_ATTACK_LABELS)))

    # Création de l'image de la matrice de confusion
    fig, ax = plt.subplots(figsize=(12, 10))
    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', 
                xticklabels=ALL_ATTACK_LABELS, yticklabels=ALL_ATTACK_LABELS, ax=ax)
    plt.xticks(rotation=45, ha='right')
    plt.yticks(rotation=0)
    ax.set_xlabel('Predicted Labels')
    ax.set_ylabel('True Labels')
    ax.set_title('Confusion Matrix')
    
    buf = io.BytesIO()
    plt.savefig(buf, format='png', bbox_inches='tight')
    buf.seek(0)
    img_b64 = base64.b64encode(buf.read()).decode('utf-8')
    plt.close(fig)
    new_analysis = AnalysisHistory(
        filename=file.filename,
        classification_report=json.dumps(report), # On convertit le dict en chaîne JSON
        confusion_matrix_b64=img_b64,
        admin_id=current_user.id # On suppose que get_current_admin_user est utilisé
    )
    db.add(new_analysis)
    db.commit()
    
    # 2. Renvoyer le résultat comme avant
    return {"report": report, "confusion_matrix_b64": img_b64}



@app.get("/api/admin/users/{user_id}", response_model=UserAdminView, dependencies=[Depends(get_current_admin_user)])
def get_user_details_for_admin(user_id: int, db: Session = Depends(get_db)):
    user = db.query(User).filter(User.id == user_id).options(selectinload(User.devices)).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
        
    # On réutilise la même logique d'enrichissement que pour la liste
    prevention_on_count = sum(1 for device in user.devices if device.prevention_enabled)
    payment_count = db.query(Payment).filter(Payment.user_id == user.id, Payment.status == 'succeeded').count()
    
    user_dict = UserPublic.model_validate(user).model_dump()
    user_dict['device_count'] = len(user.devices)
    user_dict['devices_with_prevention_on'] = prevention_on_count
    user_dict['payment_count'] = payment_count
    
    return UserAdminView.model_validate(user_dict)
@app.get("/api/admin/users/{user_id}/devices", response_model=List[DeviceWithStatus], dependencies=[Depends(get_current_admin_user)])
def get_user_devices_for_admin(user_id: int, db: Session = Depends(get_db)):
    """
    Récupère la liste de tous les appareils appartenant à un utilisateur spécifique.
    """
    user = db.query(User).filter(User.id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")

 
    response = []
    for d in user.devices:
        status_obj = db.query(DeviceStatus).filter_by(device_api_key=d.api_key).first()
        device_data = DeviceWithStatus.model_validate(d, context={'status_info': status_obj})
        response.append(device_data)
        
    return response



@app.post("/api/admin/training/start", response_model=TrainingStatus, dependencies=[Depends(get_current_admin_user)])
def start_training():
    """
    Démarre le script server.py en tant que processus en arrière-plan.
    """
    global FLOWER_PROCESS
    
    # Vérifier si un processus est déjà en cours
    if FLOWER_PROCESS and FLOWER_PROCESS.poll() is None:
        raise HTTPException(status_code=409, detail="A training session is already in progress.")

    print("🚀 Admin requested to start a new training session...")
    
    # On utilise sys.executable pour être sûr d'utiliser le même interpréteur Python
    # que celui qui exécute uvicorn (celui du venv)
    command = [sys.executable, "server.py"]
    
    # Lancer le processus
    FLOWER_PROCESS = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    
    print(f"✅ Flower server process started with PID: {FLOWER_PROCESS.pid}")
    
    return TrainingStatus(is_running=True, pid=FLOWER_PROCESS.pid)

@app.post("/api/admin/training/stop", response_model=TrainingStatus, dependencies=[Depends(get_current_admin_user)])
def stop_training():
    """
    Arrête le processus server.py en cours.
    """
    global FLOWER_PROCESS
    
    if FLOWER_PROCESS and FLOWER_PROCESS.poll() is None:
        print(f"🛑 Admin requested to stop training session (PID: {FLOWER_PROCESS.pid})...")
        FLOWER_PROCESS.terminate() # Envoie un signal pour arrêter proprement
        try:
            FLOWER_PROCESS.wait(timeout=5) # Attendre 5 secondes que le processus se termine
        except subprocess.TimeoutExpired:
            FLOWER_PROCESS.kill() # Si ce n'est pas suffisant, on le force
        print("✅ Training session stopped.")
        FLOWER_PROCESS = None
        return TrainingStatus(is_running=False)
        
    raise HTTPException(status_code=404, detail="No active training session to stop.")

@app.get("/api/admin/training/status", response_model=TrainingStatus, dependencies=[Depends(get_current_admin_user)])
def get_training_status():
    """
    Vérifie si le processus server.py est actuellement en cours d'exécution.
    """
    global FLOWER_PROCESS
    
    if FLOWER_PROCESS and FLOWER_PROCESS.poll() is None:
        # poll() renvoie None si le processus est toujours en cours
        return TrainingStatus(is_running=True, pid=FLOWER_PROCESS.pid)
    
    return TrainingStatus(is_running=False)

@app.post("/api/auth/register", response_model=UserPublic)
async def register(user_in: UserCreate, background_tasks: BackgroundTasks, db: Session = Depends(get_db)):
    if db.query(User).filter((User.email == user_in.email) | (User.username == user_in.username)).first():
        raise HTTPException(status_code=400, detail="Email or username already used")
    
    code = f"{random.randint(100000, 999999)}"
    
    # On utilise les nouveaux champs du modèle UserCreate
    user = User(
        email=user_in.email,
        username=user_in.username,
        hashed_password=get_password_hash(user_in.password),
        full_name=user_in.full_name,
        company=user_in.company,
        country=user_in.country,
        verification_code=code,
        is_active=False
    )
    db.add(user)
    db.commit()
    db.refresh(user)

    try:
        fm = FastMail(mail_conf)
        msg = MessageSchema(
            subject="FedIds - Activate Your Account",
            recipients=[user.email],
            body=f"<p>Your verification code is <b>{code}</b></p>",
            subtype="html",
        )
        background_tasks.add_task(fm.send_message, msg)
    except Exception as e:
        # non-fatal
        print("Email send error:", e)

    return UserPublic.model_validate(user)

# Flower registration
@app.post("/api/fl/register")
def fl_register(payload: FLClientRegistration, db: Session = Depends(get_db)):
    device = db.query(Device).filter_by(api_key=payload.api_key).first()
    if not device:
        raise HTTPException(status_code=404, detail="Device not found")
    if device.owner:
        device.owner.google_id = payload.flower_cid
        db.commit()
    return {"status": "registered"}


# Sequence helper for evaluation
def create_sequences_for_evaluation(X, y, time_steps=20):
    Xs, ys = [], []
    for i in range(len(X) - time_steps):
        Xs.append(X[i : (i + time_steps)])
        ys.append(y[i + time_steps])
    return np.array(Xs), np.array(ys)




# Websockets
async def get_user_from_ws_token(websocket: WebSocket, db: Session = Depends(get_db)) -> Optional[User]:
    try:
        token = websocket.query_params.get("token")
        if not token:
            await websocket.close(code=http_status.WS_1008_POLICY_VIOLATION)
            return None
        return await get_current_user(token, db)
    except Exception:
        await websocket.close(code=http_status.WS_1008_POLICY_VIOLATION)
        return None


@app.websocket("/ws/attacks")
async def websocket_attacks(websocket: WebSocket, db: Session = Depends(get_db)):
    user = await get_user_from_ws_token(websocket, db)
    if not user:
        return
    await manager.connect(websocket, "attacks")
    try:
        while True:
            await websocket.receive_text()
    except WebSocketDisconnect:
        manager.disconnect(websocket, "attacks")

@app.websocket("/ws/fl_status")
async def websocket_fl_status(websocket: WebSocket, db: Session = Depends(get_db)):
    # On utilise le helper que nous avions déjà créé
    user = await get_user_from_ws_token(websocket, db)
    if not user:
        # Si le token est invalide ou manquant, on refuse la connexion
        return

    await manager.connect(websocket, "fl_status")
    try:
        while True:
            await websocket.receive_text() # Garde la connexion ouverte
    except WebSocketDisconnect:
        manager.disconnect(websocket, "fl_s tatus")


# Google OAuth
@app.get("/api/auth/google", include_in_schema=False)
async def login_via_google(request: Request):
    redirect_uri = request.url_for("auth_via_google_callback")
    return await oauth.google.authorize_redirect(request, redirect_uri)


@app.get("/api/auth/google/callback", include_in_schema=False)
async def auth_via_google_callback(request: Request, db: Session = Depends(get_db)):
    frontend_login_url = f"{FRONTEND_BASE}/login"
    try:
        token = await oauth.google.authorize_access_token(request)
    except Exception as e:
        print(f"Error authorizing Google token: {e}")
        return RedirectResponse(url=f"{frontend_login_url}?error=google_auth_failed")

    user_info = token.get("userinfo") or token.get("id_token_claims")
    if not user_info or not user_info.get("sub") or not user_info.get("email"):
        return RedirectResponse(url=f"{frontend_login_url}?error=google_info_missing")

    google_id = user_info["sub"]
    email = user_info["email"]
    user = db.query(User).filter(User.google_id == google_id).first()
    if not user:
        user = db.query(User).filter(User.email == email).first()
        if user:
            user.google_id = google_id
            user.is_active = True
        else:
            base_username = email.split("@")[0].replace('.', '_')
            final_username = base_username
            while db.query(User).filter(User.username == final_username).first():
                final_username = f"{base_username}_{uuid.uuid4().hex[:4]}"
            user = User(email=email, google_id=google_id, username=final_username, is_active=True, role="user")
            db.add(user)
        db.commit()
        db.refresh(user)

    access_token = create_access_token(data={"sub": user.username})
    frontend_callback_url = f"{FRONTEND_BASE}/auth/callback"
    user_data_for_frontend = UserPublic.model_validate(user).model_dump_json()
    params = urlencode({"token": access_token, "user": user_data_for_frontend})
    return RedirectResponse(url=f"{frontend_callback_url}?{params}")


# Payments
@app.post("/api/payments/create-payment-intent")
def create_payment(user: User = Depends(get_current_user)):
    try:
        intent = stripe.PaymentIntent.create(
            amount=PREMIUM_PLAN_PRICE,
            currency='eur',
            automatic_payment_methods={'enabled': True},
            metadata={'user_id': user.id},
        )
        return {'clientSecret': intent.client_secret}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/api/payments/webhook")
async def stripe_webhook(request: Request, db: Session = Depends(get_db)):
    payload = await request.body()
    sig_header = request.headers.get('stripe-signature')
    endpoint_secret = os.getenv("STRIPE_WEBHOOK_SECRET")
    try:
        event = stripe.Webhook.construct_event(payload, sig_header, endpoint_secret)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Webhook error: {e}")

    if event['type'] == 'payment_intent.succeeded':
        intent = event['data']['object']
        user_id = intent['metadata'].get('user_id')
        if user_id:
            user = db.query(User).filter(User.id == int(user_id)).first()
            if user and user.role != 'premium':
                user.role = 'premium'
                user.subscription_valid_until = datetime.utcnow() + timedelta(days=30)
                db.commit()
    elif event['type'] == 'payment_intent.payment_failed':
        intent = event['data']['object']
        user_id = intent['metadata'].get('user_id')
        print(f"❌ Webhook FAILED: Payment failed for user ID {user_id}.")

    return {"status": "success"}



# --- TICKETS (ADMIN) ---

def analyze_ticket_content(subject: str, message: str) ->  Tuple[str, str]:
    """
    Analyse le contenu d'un ticket pour déterminer sa catégorie et sa priorité.
    C'est une simulation d'IA simple.
    """
    text = (subject + " " + message).lower()
    
    # Détermination de la priorité
    if "urgent" in text or "critical" in text or "down" in text:
        priority = "critical"
    elif "billing" in text or "payment" in text or "invoice" in text:
        priority = "high"
    else:
        priority = "medium"
        
    # Détermination de la catégorie
    if "billing" in text or "payment" in text:
        category = "billing"
    elif "bug" in text or "error" in text or "not working" in text:
        category = "technical"
    else:
        category = "general"
        
    return category, priority


# Endpoint pour créer un ticket (utilisé par l'utilisateur)
# Dans main.py

@app.post("/api/tickets", status_code=201)
def create_ticket(ticket_data: TicketCreate, current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    print("--- 1. Début de la création du ticket ---")
    _, priority = analyze_ticket_content(ticket_data.subject, ticket_data.message)
    
    new_ticket = Ticket(
        user_id=current_user.id,
        subject=ticket_data.subject,
        category=ticket_data.category, # On utilise la catégorie fournie
        priority=priority
    )
    db.add(new_ticket)
    print("--- 2. Ticket ajouté à la session SQLAlchemy ---")
    
    try:
        db.commit()
        print("--- 3. COMMIT RÉUSSI pour le ticket ---")
        db.refresh(new_ticket)
        
        initial_message = TicketMessage(
            ticket_id=new_ticket.id,
            author_id=current_user.id,
            message=ticket_data.message
        )
        db.add(initial_message)
        print("--- 4. Message ajouté à la session ---")
        
        db.commit()
        print("--- 5. COMMIT RÉUSSI pour le message ---")
        
        return new_ticket
        
    except Exception as e:
        print(f"❌ ERREUR PENDANT LE COMMIT : {e}")
        db.rollback() # Annuler la transaction en cas d'erreur
        raise HTTPException(status_code=500, detail="Database error occurred.")

# Endpoint pour qu'un utilisateur voie ses propres tickets
@app.get("/api/tickets/my-tickets")
def get_my_tickets(current_user: User = Depends(get_current_user)):
    return current_user.tickets

# Endpoint pour qu'un admin voie TOUS les tickets
@app.get("/api/admin/tickets", dependencies=[Depends(get_current_admin_user)])
def get_all_tickets(db: Session = Depends(get_db)):
    # === LA CORRECTION EST ICI ===
    # On utilise .options(joinedload(Ticket.user)) pour forcer le chargement
    # de la relation 'user' en même temps que les tickets.
    return db.query(Ticket).options(joinedload(Ticket.user)).order_by(Ticket.updated_at.desc()).all()

# Endpoint pour voir les détails d'un ticket (messages inclus)

@app.get("/api/tickets/{ticket_id}")
def get_ticket_details(ticket_id: int, current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    # === LA CORRECTION EST ICI ===
    # On utilise un joinedload "chaîné" pour charger les messages ET l'auteur de chaque message.
    ticket = db.query(Ticket).options(
        joinedload(Ticket.messages).joinedload(TicketMessage.author)
    ).filter(Ticket.id == ticket_id).first()
    
    # Vérifier que l'utilisateur a le droit de voir ce ticket
    if not ticket or (ticket.user_id != current_user.id and current_user.role != 'admin'):
        raise HTTPException(status_code=404, detail="Ticket not found")
        
    return ticket
@app.post("/api/tickets/{ticket_id}/close", status_code=200)
def close_ticket(
    ticket_id: int, 
    current_user: User = Depends(get_current_user), 
    db: Session = Depends(get_db)
):
    """
    Permet à un admin de clore n'importe quel ticket.
    (On pourrait aussi autoriser l'utilisateur, mais on se concentre sur le besoin de l'admin).
    """
    ticket = db.query(Ticket).filter(Ticket.id == ticket_id).first()
    
    # === LA LOGIQUE DE PERMISSION CORRIGÉE ===
    # On vérifie d'abord si le ticket existe
    if not ticket:
        raise HTTPException(status_code=404, detail="Ticket not found.")
        
    # Ensuite, on vérifie si l'utilisateur est un admin
    if current_user.role != 'admin':
        raise HTTPException(status_code=403, detail="You do not have permission to close this ticket.")
        
    if ticket.status == 'closed':
        raise HTTPException(status_code=400, detail="Ticket is already closed.")

    ticket.status = "closed"
    ticket.updated_at = datetime.utcnow()
    db.commit()
    
    return {"message": "Ticket has been closed successfully by admin."}
# Endpoint pour répondre à un ticket
@app.post("/api/tickets/{ticket_id}/reply")
def reply_to_ticket(
    ticket_id: int, 
    message_data: TicketMessageCreate, 
    background_tasks: BackgroundTasks, # <-- Ajouté pour les emails
    current_user: User = Depends(get_current_user), 
    db: Session = Depends(get_db)
):
    ticket = db.query(Ticket).options(joinedload(Ticket.user)).filter(Ticket.id == ticket_id).first()
    
    # Vérifier les permissions
    if not ticket or (ticket.user_id != current_user.id and current_user.role != 'admin'):
        raise HTTPException(status_code=404, detail="Ticket not found")

    # Créer le nouveau message
    new_message = TicketMessage(
        ticket_id=ticket.id,
        author_id=current_user.id,
        message=message_data.message
    )
    db.add(new_message)
    
    # Mettre à jour le statut et la date du ticket
    if current_user.role == 'admin':
        ticket.status = "pending_user" # L'admin a répondu, en attente de l'utilisateur
        
        # === NOTIFICATION PAR EMAIL ===
        user_to_notify = ticket.user
        fm = FastMail(mail_conf)
        msg = MessageSchema(
            subject=f"Re: Your ticket #{ticket.id} - {ticket.subject}",
            recipients=[user_to_notify.email],
            body=f"<p>A support agent has replied to your ticket. Please log in to view the response.</p>",
            subtype="html"
        )
        background_tasks.add_task(fm.send_message, msg)
        
    else: # C'est un utilisateur qui répond
        ticket.status = "pending_admin"
    
    ticket.updated_at = datetime.utcnow()
    
    db.commit()
    db.refresh(new_message)
    return new_message
@app.post("/api/admin/tickets/{ticket_id}/assign", dependencies=[Depends(get_current_admin_user)])
def assign_ticket(ticket_id: int, current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    ticket = db.query(Ticket).filter(Ticket.id == ticket_id).first()
    if not ticket: raise HTTPException(404, "Ticket not found")
    
    ticket.assigned_admin_id = current_user.id
    ticket.status = "in_progress"
    db.commit()
    return {"message": f"Ticket assigned to {current_user.username}"}

@app.get("/api/faq/search")
def search_faq(query: str, db: Session = Depends(get_db)):
    """
    Recherche simple par mots-clés dans la base de connaissances.
    """
    return db.query(FaqArticle).filter(FaqArticle.keywords.contains(query.lower())).all()

@app.post("/api/auth/forgot-password")
async def forgot_password(req: ForgotPasswordRequest, background_tasks: BackgroundTasks, db: Session = Depends(get_db)):
    user = db.query(User).filter(User.email == req.email).first()
    
    # Pour des raisons de sécurité, on ne révèle jamais si l'email existe ou non.
    # On renvoie toujours un message de succès.
    if user:
        # Générer un token sécurisé
        token = secrets.token_hex(20)
        user.password_reset_token = token
        user.password_reset_expires = datetime.utcnow() + timedelta(hours=1) # Valide 1 heure
        db.commit()
        
        # Envoyer l'email en arrière-plan
        reset_link = f"http://localhost:5173/reset-password?token={token}"
        fm = FastMail(mail_conf)
        msg = MessageSchema(subject="FedIds - Reset Your Password", recipients=[user.email],
                            body=f"<p>Click here to reset your password: <a href='{reset_link}'>{reset_link}</a></p>", subtype="html")
        background_tasks.add_task(fm.send_message, msg)
        
    return {"message": "If an account with this email exists, a password reset link has been sent."}

@app.post("/api/auth/reset-password")
def reset_password(req: ResetPasswordRequest, db: Session = Depends(get_db)):
    user = db.query(User).filter(User.password_reset_token == req.token).first()
    
    if not user or user.password_reset_expires < datetime.utcnow():
        raise HTTPException(status_code=400, detail="Invalid or expired token.")
        
    user.hashed_password = get_password_hash(req.new_password)
    user.password_reset_token = None # Invalider le token après utilisation
    user.password_reset_expires = None
    db.commit()
    
    return {"message": "Password has been reset successfully."}

@app.post("/api/chatbot/query", response_model=ChatResponse, dependencies=[Depends(get_current_user)])
async def handle_chat_query(query: ChatQuery, user: User = Depends(get_current_user),db: Session = Depends(get_db)):
    if user.role != 'premium':
        raise HTTPException(status_code=403, detail="Chatbot is a premium feature.")
    
    if not GEMINI_API_KEY:
        raise HTTPException(status_code=500, detail="Chatbot is not configured on the server.")
# === LA MODIFICATION EST ICI ===
    # On enregistre la question de l'utilisateur dans la base de données
    new_log = ChatLog(user_id=user.id, question=query.question)
    db.add(new_log)
    db.commit()
    try:
        model = genai.GenerativeModel('gemini-1.5-flash')
        
        # === LA CORRECTION EST ICI ===
        
        # 1. Définir le contexte et les instructions
        system_prompt = """
        You are FedIds Assist, a specialized AI assistant for a Federated Intrusion Detection System (FedIds).
        Your purpose is to help users understand cybersecurity threats in an Industrial IoT (IIoT) context.
        Your knowledge is focused on these attacks: Backdoor, DDoS, MITM, Port Scanning, Ransomware.
        Be concise and helpful. If asked about topics outside of IIoT security, politely decline.
        """
        
        # 2. Construire l'historique pour l'API
        messages_for_api = []
        
        # 3. Injecter les instructions dans le premier message de l'historique
        # S'il n'y a pas d'historique, on crée le premier message avec le prompt
        if not query.history:
            first_question = f"{system_prompt}\n\nUSER QUESTION: {query.question}"
            messages_for_api.append({"role": "user", "parts": [first_question]})
        else:
            # S'il y a un historique, on le reconstruit normalement
            for message in query.history:
                # On s'assure que le rôle est bien 'user' ou 'model'
                role = "user" if message["role"] == "user" else "model"
                messages_for_api.append({"role": role, "parts": [message["text"]]})
            # Et on ajoute la nouvelle question de l'utilisateur
            messages_for_api.append({"role": "user", "parts": [query.question]})
        # On interroge l'API
        response = await model.generate_content_async(messages_for_api)
        
        return ChatResponse(answer=response.text)

    except Exception as e:
        print(f"Gemini API Error: {e}")
        raise HTTPException(status_code=500, detail="An error occurred while communicating with the AI assistant.")

@app.get("/api/admin/chatbot/stats", response_model=List[ChatStat], dependencies=[Depends(get_current_admin_user)])
def get_chatbot_stats(db: Session = Depends(get_db)):
    """
    Compte les occurrences de chaque question posée au chatbot
    et renvoie les 10 plus fréquentes.
    """
    # On groupe par question, on compte, on ordonne par le compte, et on prend les 10 premières
    stats = db.query(
        ChatLog.question, 
        func.count(ChatLog.question).label('count')
    ).group_by(ChatLog.question).order_by(func.count(ChatLog.question).desc()).limit(10).all()
    
    return stats
# ------------------------------------------------------------
# WebSockets routes
# ------------------------------------------------------------
@app.websocket("/ws/attacks")
async def websocket_attacks(websocket: WebSocket, db: Session = Depends(get_db)):
    token = websocket.query_params.get("token")
    if not token:
        await websocket.close(code=http_status.WS_1008_POLICY_VIOLATION)
        return
    user = await get_current_user(token, db)
    await manager.connect(websocket, "attacks")
    try:
        while True:
            await websocket.receive_text()
    except WebSocketDisconnect:
        manager.disconnect(websocket, "attacks")

# ------------------------------------------------------------
# SECTION 10: Uvicorn launcher
# ------------------------------------------------------------
if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=int(os.getenv('PORT', 8000)), reload=True)
